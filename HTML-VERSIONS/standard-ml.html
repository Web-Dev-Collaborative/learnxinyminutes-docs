<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>standard-ml.html</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>Standard ML is a functional programming language with type inference and some side-effects. Some of the hard parts of learning Standard ML are: Recursion, pattern matching, type inference (guessing the right types but never allowing implicit type conversion). Standard ML is distinguished from Haskell by including references, allowing variables to be updated.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1"><span class="co">(* Comments in Standard ML begin with (* and end with *).  Comments can be</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">   nested which means that all (* tags must end with a *) tag.  This comment,</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">   for example, contains two nested comments. *)</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">(* A Standard ML program consists of declarations, e.g. value declarations: *)</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">val</span> rent = <span class="dv">1200</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">val</span> phone_no = <span class="dv">5551337</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">val</span> pi = <span class="fl">3.14159</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">val</span> negative_number = ~<span class="dv">15</span>  <span class="co">(* Yeah, unary minus uses the &#39;tilde&#39; symbol *)</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">(* Optionally, you can explicitly declare types. This is not necessary as</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">   ML will automatically figure out the types of your values. *)</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">val</span> diameter = <span class="dv">7926</span> : <span class="dt">int</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">val</span> e = <span class="fl">2.718</span> : <span class="dt">real</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">val</span> name = <span class="st">&quot;Bobby&quot;</span> : <span class="dt">string</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">(* And just as importantly, functions: *)</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="kw">fun</span> is_large(x : <span class="dt">int</span>) = <span class="kw">if</span> x &gt; <span class="dv">37</span> <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">(* Floating-point numbers are called &quot;reals&quot;. *)</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">val</span> tau = <span class="fl">2.0</span> * pi         <span class="co">(* You can multiply two reals *)</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="kw">val</span> twice_rent = <span class="dv">2</span> * rent  <span class="co">(* You can multiply two ints *)</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">(* val meh = 1.25 * 10 *)</span>  <span class="co">(* But you can&#39;t multiply an int and a real *)</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="kw">val</span> yeh = <span class="fl">1.25</span> * (Real.fromInt <span class="dv">10</span>) <span class="co">(* ...unless you explicitly convert</span></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">                                      one or the other *)</span></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">(* +, - and * are overloaded so they work for both int and real. *)</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co">(* The same cannot be said for division which has separate operators: *)</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="kw">val</span> real_division = <span class="fl">14.0</span> / <span class="fl">4.0</span>  <span class="co">(* gives 3.5 *)</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="kw">val</span> int_division  = <span class="dv">14</span> div <span class="dv">4</span>    <span class="co">(* gives 3, rounding down *)</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="kw">val</span> int_remainder = <span class="dv">14</span> <span class="kw">mod</span> <span class="dv">4</span>    <span class="co">(* gives 2, since 3*4 = 12 *)</span></a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">(* ~ is actually sometimes a function (e.g. when put in front of variables) *)</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="kw">val</span> negative_rent = ~(rent)  <span class="co">(* Would also have worked if rent were a &quot;real&quot; *)</span></a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">(* There are also booleans and boolean operators *)</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="kw">val</span> got_milk = <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="kw">val</span> got_bread = <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="kw">val</span> has_breakfast = got_milk andalso got_bread  <span class="co">(* &#39;andalso&#39; is the operator *)</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="kw">val</span> has_something = got_milk orelse got_bread   <span class="co">(* &#39;orelse&#39; is the operator *)</span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="kw">val</span> is_sad = <span class="dt">not</span>(has_something)                 <span class="co">(* not is a function *)</span></a>
<a class="sourceLine" id="cb1-42" title="42"></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">(* Many values can be compared using equality operators: = and &lt;&gt; *)</span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="kw">val</span> pays_same_rent = (rent = <span class="dv">1300</span>)  <span class="co">(* false *)</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="kw">val</span> is_wrong_phone_no = (phone_no &lt;&gt; <span class="dv">5551337</span>)  <span class="co">(* false *)</span></a>
<a class="sourceLine" id="cb1-46" title="46"></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">(* The operator &lt;&gt; is what most other languages call !=. *)</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">(* &#39;andalso&#39; and &#39;orelse&#39; are called &amp;&amp; and || in many other languages. *)</span></a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="co">(* Actually, most of the parentheses above are unnecessary.  Here are some</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">   different ways to say some of the things mentioned above: *)</span></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="kw">fun</span> is_large x = x &gt; <span class="dv">37</span>  <span class="co">(* The parens above were necessary because of &#39;: int&#39; *)</span></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="kw">val</span> is_sad = <span class="dt">not</span> has_something</a>
<a class="sourceLine" id="cb1-54" title="54"><span class="kw">val</span> pays_same_rent = rent = <span class="dv">1300</span>  <span class="co">(* Looks confusing, but works *)</span></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="kw">val</span> is_wrong_phone_no = phone_no &lt;&gt; <span class="dv">5551337</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="kw">val</span> negative_rent = ~rent  <span class="co">(* ~ rent (notice the space) would also work *)</span></a>
<a class="sourceLine" id="cb1-57" title="57"></a>
<a class="sourceLine" id="cb1-58" title="58"><span class="co">(* Parentheses are mostly necessary when grouping things: *)</span></a>
<a class="sourceLine" id="cb1-59" title="59"><span class="kw">val</span> some_answer = is_large (<span class="dv">5</span> + <span class="dv">5</span>)      <span class="co">(* Without parens, this would break! *)</span></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="co">(* val some_answer = is_large 5 + 5 *)</span>  <span class="co">(* Read as: (is_large 5) + 5. Bad! *)</span></a>
<a class="sourceLine" id="cb1-61" title="61"></a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63"><span class="co">(* Besides booleans, ints and reals, Standard ML also has chars and strings: *)</span></a>
<a class="sourceLine" id="cb1-64" title="64"><span class="kw">val</span> foo = <span class="st">&quot;Hello, World!</span><span class="ch">\n</span><span class="st">&quot;</span>  <span class="co">(* The \n is the escape sequence for linebreaks *)</span></a>
<a class="sourceLine" id="cb1-65" title="65"><span class="kw">val</span> one_letter = #<span class="st">&quot;a&quot;</span>        <span class="co">(* That funky syntax is just one character, a *)</span></a>
<a class="sourceLine" id="cb1-66" title="66"></a>
<a class="sourceLine" id="cb1-67" title="67"><span class="kw">val</span> combined = <span class="st">&quot;Hello &quot;</span> ^ <span class="st">&quot;there, &quot;</span> ^ <span class="st">&quot;fellow!</span><span class="ch">\n</span><span class="st">&quot;</span>  <span class="co">(* Concatenate strings *)</span></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="kw">val</span> _ = print foo       <span class="co">(* You can print things. We are not interested in the *)</span></a>
<a class="sourceLine" id="cb1-70" title="70"><span class="kw">val</span> _ = print combined  <span class="co">(* result of this computation, so we throw it away. *)</span></a>
<a class="sourceLine" id="cb1-71" title="71"><span class="co">(* val _ = print one_letter *)</span>  <span class="co">(* Only strings can be printed this way *)</span></a>
<a class="sourceLine" id="cb1-72" title="72"></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="kw">val</span> bar = [ #<span class="st">&quot;H&quot;</span>, #<span class="st">&quot;e&quot;</span>, #<span class="st">&quot;l&quot;</span>, #<span class="st">&quot;l&quot;</span>, #<span class="st">&quot;o&quot;</span> ]  <span class="co">(* SML also has lists! *)</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">(* val _ = print bar *)</span>  <span class="co">(* Lists are unfortunately not the same as strings *)</span></a>
<a class="sourceLine" id="cb1-76" title="76"></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">(* Fortunately they can be converted.  String is a library and implode and size</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="co">   are functions available in that library that take strings as argument. *)</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="kw">val</span> bob = <span class="dt">String</span>.implode bar          <span class="co">(* gives &quot;Hello&quot; *)</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="kw">val</span> bob_char_count = <span class="dt">String</span>.size bob  <span class="co">(* gives 5 *)</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="kw">val</span> _ = print (bob ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)            <span class="co">(* For good measure, add a linebreak *)</span></a>
<a class="sourceLine" id="cb1-82" title="82"></a>
<a class="sourceLine" id="cb1-83" title="83"><span class="co">(* You can have lists of any kind *)</span></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="kw">val</span> numbers = [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">229</span>, <span class="dv">230</span>, <span class="dv">248</span>]  <span class="co">(* : int list *)</span></a>
<a class="sourceLine" id="cb1-85" title="85"><span class="kw">val</span> names = [ <span class="st">&quot;Fred&quot;</span>, <span class="st">&quot;Jane&quot;</span>, <span class="st">&quot;Alice&quot;</span> ]    <span class="co">(* : string list *)</span></a>
<a class="sourceLine" id="cb1-86" title="86"></a>
<a class="sourceLine" id="cb1-87" title="87"><span class="co">(* Even lists of lists of things *)</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="kw">val</span> groups = [ [ <span class="st">&quot;Alice&quot;</span>, <span class="st">&quot;Bob&quot;</span> ],</a>
<a class="sourceLine" id="cb1-89" title="89">               [ <span class="st">&quot;Huey&quot;</span>, <span class="st">&quot;Dewey&quot;</span>, <span class="st">&quot;Louie&quot;</span> ],</a>
<a class="sourceLine" id="cb1-90" title="90">               [ <span class="st">&quot;Bonnie&quot;</span>, <span class="st">&quot;Clyde&quot;</span> ] ]     <span class="co">(* : string list list *)</span></a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="kw">val</span> number_count = <span class="dt">List</span>.length numbers     <span class="co">(* gives 7 *)</span></a>
<a class="sourceLine" id="cb1-93" title="93"></a>
<a class="sourceLine" id="cb1-94" title="94"><span class="co">(* You can put single values in front of lists of the same kind using</span></a>
<a class="sourceLine" id="cb1-95" title="95"><span class="co">   the :: operator, called &quot;the cons operator&quot; (known from Lisp). *)</span></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="kw">val</span> more_numbers = <span class="dv">13</span> :: numbers  <span class="co">(* gives [13, 1, 3, 3, 7, ...] *)</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="kw">val</span> more_groups  = [<span class="st">&quot;Batman&quot;</span>,<span class="st">&quot;Superman&quot;</span>] :: groups</a>
<a class="sourceLine" id="cb1-98" title="98"></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="co">(* Lists of the same kind can be appended using the @ (&quot;append&quot;) operator *)</span></a>
<a class="sourceLine" id="cb1-100" title="100"><span class="kw">val</span> guest_list = [ <span class="st">&quot;Mom&quot;</span>, <span class="st">&quot;Dad&quot;</span> ] @ [ <span class="st">&quot;Aunt&quot;</span>, <span class="st">&quot;Uncle&quot;</span> ]</a>
<a class="sourceLine" id="cb1-101" title="101"></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="co">(* This could have been done with the &quot;cons&quot; operator.  It is tricky because the</span></a>
<a class="sourceLine" id="cb1-103" title="103"><span class="co">   left-hand-side must be an element whereas the right-hand-side must be a list</span></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="co">   of those elements. *)</span></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="kw">val</span> guest_list = <span class="st">&quot;Mom&quot;</span> :: <span class="st">&quot;Dad&quot;</span> :: [ <span class="st">&quot;Aunt&quot;</span>, <span class="st">&quot;Uncle&quot;</span> ]</a>
<a class="sourceLine" id="cb1-106" title="106"><span class="kw">val</span> guest_list = <span class="st">&quot;Mom&quot;</span> :: (<span class="st">&quot;Dad&quot;</span> :: (<span class="st">&quot;Aunt&quot;</span> :: (<span class="st">&quot;Uncle&quot;</span> :: [])))</a>
<a class="sourceLine" id="cb1-107" title="107"></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="co">(* If you have many lists of the same kind, you can concatenate them all *)</span></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="kw">val</span> everyone = <span class="dt">List</span>.concat groups  <span class="co">(* [ &quot;Alice&quot;, &quot;Bob&quot;, &quot;Huey&quot;, ... ] *)</span></a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="co">(* A list can contain any (finite) number of values *)</span></a>
<a class="sourceLine" id="cb1-112" title="112"><span class="kw">val</span> lots = [ <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">3</span> ]  <span class="co">(* still just an int list *)</span></a>
<a class="sourceLine" id="cb1-113" title="113"></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="co">(* Lists can only contain one kind of thing... *)</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="co">(* val bad_list = [ 1, &quot;Hello&quot;, 3.14159 ] : ??? list *)</span></a>
<a class="sourceLine" id="cb1-116" title="116"></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"><span class="co">(* Tuples, on the other hand, can contain a fixed number of different things *)</span></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="kw">val</span> person1 = (<span class="st">&quot;Simon&quot;</span>, <span class="dv">28</span>, <span class="fl">3.14159</span>)  <span class="co">(* : string * int * real *)</span></a>
<a class="sourceLine" id="cb1-120" title="120"></a>
<a class="sourceLine" id="cb1-121" title="121"><span class="co">(* You can even have tuples inside lists and lists inside tuples *)</span></a>
<a class="sourceLine" id="cb1-122" title="122"><span class="kw">val</span> likes = [ (<span class="st">&quot;Alice&quot;</span>, <span class="st">&quot;ice cream&quot;</span>),</a>
<a class="sourceLine" id="cb1-123" title="123">              (<span class="st">&quot;Bob&quot;</span>,   <span class="st">&quot;hot dogs&quot;</span>),</a>
<a class="sourceLine" id="cb1-124" title="124">              (<span class="st">&quot;Bob&quot;</span>,   <span class="st">&quot;Alice&quot;</span>) ]     <span class="co">(* : (string * string) list *)</span></a>
<a class="sourceLine" id="cb1-125" title="125"></a>
<a class="sourceLine" id="cb1-126" title="126"><span class="kw">val</span> mixup = [ (<span class="st">&quot;Alice&quot;</span>, <span class="dv">39</span>),</a>
<a class="sourceLine" id="cb1-127" title="127">              (<span class="st">&quot;Bob&quot;</span>,   <span class="dv">37</span>),</a>
<a class="sourceLine" id="cb1-128" title="128">              (<span class="st">&quot;Eve&quot;</span>,   <span class="dv">41</span>) ]  <span class="co">(* : (string * int) list *)</span></a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130"><span class="kw">val</span> good_bad_stuff =</a>
<a class="sourceLine" id="cb1-131" title="131">  ([<span class="st">&quot;ice cream&quot;</span>, <span class="st">&quot;hot dogs&quot;</span>, <span class="st">&quot;chocolate&quot;</span>],</a>
<a class="sourceLine" id="cb1-132" title="132">   [<span class="st">&quot;liver&quot;</span>, <span class="st">&quot;paying the rent&quot;</span> ])           <span class="co">(* : string list * string list *)</span></a>
<a class="sourceLine" id="cb1-133" title="133"></a>
<a class="sourceLine" id="cb1-134" title="134"></a>
<a class="sourceLine" id="cb1-135" title="135"><span class="co">(* Records are tuples with named slots *)</span></a>
<a class="sourceLine" id="cb1-136" title="136"></a>
<a class="sourceLine" id="cb1-137" title="137"><span class="kw">val</span> rgb = { r=<span class="fl">0.23</span>, g=<span class="fl">0.56</span>, b=<span class="fl">0.91</span> } <span class="co">(* : {b:real, g:real, r:real} *)</span></a>
<a class="sourceLine" id="cb1-138" title="138"></a>
<a class="sourceLine" id="cb1-139" title="139"><span class="co">(* You don&#39;t need to declare their slots ahead of time. Records with</span></a>
<a class="sourceLine" id="cb1-140" title="140"><span class="co">   different slot names are considered different types, even if their</span></a>
<a class="sourceLine" id="cb1-141" title="141"><span class="co">   slot value types match up. For instance... *)</span></a>
<a class="sourceLine" id="cb1-142" title="142"></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="kw">val</span> Hsl = { H=<span class="fl">310.3</span>, s=<span class="fl">0.51</span>, l=<span class="fl">0.23</span> } <span class="co">(* : {H:real, l:real, s:real} *)</span></a>
<a class="sourceLine" id="cb1-144" title="144"><span class="kw">val</span> Hsv = { H=<span class="fl">310.3</span>, s=<span class="fl">0.51</span>, v=<span class="fl">0.23</span> } <span class="co">(* : {H:real, s:real, v:real} *)</span></a>
<a class="sourceLine" id="cb1-145" title="145"></a>
<a class="sourceLine" id="cb1-146" title="146"><span class="co">(* ...trying to evaluate `Hsv = Hsl` or `rgb = Hsl` would give a type</span></a>
<a class="sourceLine" id="cb1-147" title="147"><span class="co">   error. While they&#39;re all three-slot records composed only of `real`s,</span></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">   they each have different names for at least some slots. *)</span></a>
<a class="sourceLine" id="cb1-149" title="149"></a>
<a class="sourceLine" id="cb1-150" title="150"><span class="co">(* You can use hash notation to get values out of tuples. *)</span></a>
<a class="sourceLine" id="cb1-151" title="151"></a>
<a class="sourceLine" id="cb1-152" title="152"><span class="kw">val</span> H = #H Hsv <span class="co">(* : real *)</span></a>
<a class="sourceLine" id="cb1-153" title="153"><span class="kw">val</span> s = #s Hsl <span class="co">(* : real *)</span></a>
<a class="sourceLine" id="cb1-154" title="154"></a>
<a class="sourceLine" id="cb1-155" title="155"><span class="co">(* Functions! *)</span></a>
<a class="sourceLine" id="cb1-156" title="156"><span class="kw">fun</span> add_them (a, b) = a + b    <span class="co">(* A simple function that adds two numbers *)</span></a>
<a class="sourceLine" id="cb1-157" title="157"><span class="kw">val</span> test_it = add_them (<span class="dv">3</span>, <span class="dv">4</span>)  <span class="co">(* gives 7 *)</span></a>
<a class="sourceLine" id="cb1-158" title="158"></a>
<a class="sourceLine" id="cb1-159" title="159"><span class="co">(* Larger functions are usually broken into several lines for readability *)</span></a>
<a class="sourceLine" id="cb1-160" title="160"><span class="kw">fun</span> thermometer temp =</a>
<a class="sourceLine" id="cb1-161" title="161">    <span class="kw">if</span> temp &lt; <span class="dv">37</span></a>
<a class="sourceLine" id="cb1-162" title="162">    <span class="kw">then</span> <span class="st">&quot;Cold&quot;</span></a>
<a class="sourceLine" id="cb1-163" title="163">    <span class="kw">else</span> <span class="kw">if</span> temp &gt; <span class="dv">37</span></a>
<a class="sourceLine" id="cb1-164" title="164">         <span class="kw">then</span> <span class="st">&quot;Warm&quot;</span></a>
<a class="sourceLine" id="cb1-165" title="165">         <span class="kw">else</span> <span class="st">&quot;Normal&quot;</span></a>
<a class="sourceLine" id="cb1-166" title="166"></a>
<a class="sourceLine" id="cb1-167" title="167"><span class="kw">val</span> test_thermo = thermometer <span class="dv">40</span>  <span class="co">(* gives &quot;Warm&quot; *)</span></a>
<a class="sourceLine" id="cb1-168" title="168"></a>
<a class="sourceLine" id="cb1-169" title="169"><span class="co">(* if-sentences are actually expressions and not statements/declarations.</span></a>
<a class="sourceLine" id="cb1-170" title="170"><span class="co">   A function body can only contain one expression.  There are some tricks</span></a>
<a class="sourceLine" id="cb1-171" title="171"><span class="co">   for making a function do more than just one thing, though. *)</span></a>
<a class="sourceLine" id="cb1-172" title="172"></a>
<a class="sourceLine" id="cb1-173" title="173"><span class="co">(* A function can call itself as part of its result (recursion!) *)</span></a>
<a class="sourceLine" id="cb1-174" title="174"><span class="kw">fun</span> fibonacci n =</a>
<a class="sourceLine" id="cb1-175" title="175">    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span>                   <span class="co">(* Base case *)</span></a>
<a class="sourceLine" id="cb1-176" title="176">    <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span>                   <span class="co">(* Base case *)</span></a>
<a class="sourceLine" id="cb1-177" title="177">    fibonacci (n - <span class="dv">1</span>) + fibonacci (n - <span class="dv">2</span>)  <span class="co">(* Recursive case *)</span></a>
<a class="sourceLine" id="cb1-178" title="178"></a>
<a class="sourceLine" id="cb1-179" title="179"><span class="co">(* Sometimes recursion is best understood by evaluating a function by hand:</span></a>
<a class="sourceLine" id="cb1-180" title="180"></a>
<a class="sourceLine" id="cb1-181" title="181"><span class="co"> fibonacci 4</span></a>
<a class="sourceLine" id="cb1-182" title="182"><span class="co">   ~&gt; fibonacci (4 - 1) + fibonacci (4 - 2)</span></a>
<a class="sourceLine" id="cb1-183" title="183"><span class="co">   ~&gt; fibonacci 3 + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-184" title="184"><span class="co">   ~&gt; (fibonacci (3 - 1) + fibonacci (3 - 2)) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">   ~&gt; (fibonacci 2 + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-186" title="186"><span class="co">   ~&gt; ((fibonacci (2 - 1) + fibonacci (2 - 2)) + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="co">   ~&gt; ((fibonacci 1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-188" title="188"><span class="co">   ~&gt; ((1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">   ~&gt; ((1 + 0) + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-190" title="190"><span class="co">   ~&gt; (1 + fibonacci 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-191" title="191"><span class="co">   ~&gt; (1 + 1) + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="co">   ~&gt; 2 + fibonacci 2</span></a>
<a class="sourceLine" id="cb1-193" title="193"><span class="co">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span></a>
<a class="sourceLine" id="cb1-194" title="194"><span class="co">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span></a>
<a class="sourceLine" id="cb1-195" title="195"><span class="co">   ~&gt; 2 + (fibonacci 1 + fibonacci 0)</span></a>
<a class="sourceLine" id="cb1-196" title="196"><span class="co">   ~&gt; 2 + (1 + fibonacci 0)</span></a>
<a class="sourceLine" id="cb1-197" title="197"><span class="co">   ~&gt; 2 + (1 + 0)</span></a>
<a class="sourceLine" id="cb1-198" title="198"><span class="co">   ~&gt; 2 + 1</span></a>
<a class="sourceLine" id="cb1-199" title="199"><span class="co">   ~&gt; 3  which is the 4th Fibonacci number, according to this definition</span></a>
<a class="sourceLine" id="cb1-200" title="200"></a>
<a class="sourceLine" id="cb1-201" title="201"><span class="co"> *)</span></a>
<a class="sourceLine" id="cb1-202" title="202"></a>
<a class="sourceLine" id="cb1-203" title="203"><span class="co">(* A function cannot change the variables it can refer to.  It can only</span></a>
<a class="sourceLine" id="cb1-204" title="204"><span class="co">   temporarily shadow them with new variables that have the same names.  In this</span></a>
<a class="sourceLine" id="cb1-205" title="205"><span class="co">   sense, variables are really constants and only behave like variables when</span></a>
<a class="sourceLine" id="cb1-206" title="206"><span class="co">   dealing with recursion.  For this reason, variables are also called value</span></a>
<a class="sourceLine" id="cb1-207" title="207"><span class="co">   bindings. An example of this: *)</span></a>
<a class="sourceLine" id="cb1-208" title="208"></a>
<a class="sourceLine" id="cb1-209" title="209"><span class="kw">val</span> x = <span class="dv">42</span></a>
<a class="sourceLine" id="cb1-210" title="210"><span class="kw">fun</span> answer(question) =</a>
<a class="sourceLine" id="cb1-211" title="211">    <span class="kw">if</span> question = <span class="st">&quot;What is the meaning of life, the universe and everything?&quot;</span></a>
<a class="sourceLine" id="cb1-212" title="212">    <span class="kw">then</span> x</a>
<a class="sourceLine" id="cb1-213" title="213">    <span class="kw">else</span> <span class="dt">raise</span> Fail <span class="st">&quot;I&#39;m an exception. Also, I don&#39;t know what the answer is.&quot;</span></a>
<a class="sourceLine" id="cb1-214" title="214"><span class="kw">val</span> x = <span class="dv">43</span></a>
<a class="sourceLine" id="cb1-215" title="215"><span class="kw">val</span> hmm = answer <span class="st">&quot;What is the meaning of life, the universe and everything?&quot;</span></a>
<a class="sourceLine" id="cb1-216" title="216"><span class="co">(* Now, hmm has the value 42.  This is because the function answer refers to</span></a>
<a class="sourceLine" id="cb1-217" title="217"><span class="co">   the copy of x that was visible before its own function definition. *)</span></a>
<a class="sourceLine" id="cb1-218" title="218"></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220"><span class="co">(* Functions can take several arguments by taking one tuples as argument: *)</span></a>
<a class="sourceLine" id="cb1-221" title="221"><span class="kw">fun</span> solve2 (a : <span class="dt">real</span>, b : <span class="dt">real</span>, c : <span class="dt">real</span>) =</a>
<a class="sourceLine" id="cb1-222" title="222">    ((~b + Math.<span class="dt">sqrt</span>(b * b - <span class="fl">4.0</span> * a * c)) / (<span class="fl">2.0</span> * a),</a>
<a class="sourceLine" id="cb1-223" title="223">     (~b - Math.<span class="dt">sqrt</span>(b * b - <span class="fl">4.0</span> * a * c)) / (<span class="fl">2.0</span> * a))</a>
<a class="sourceLine" id="cb1-224" title="224"></a>
<a class="sourceLine" id="cb1-225" title="225"><span class="co">(* Sometimes, the same computation is carried out several times. It makes sense</span></a>
<a class="sourceLine" id="cb1-226" title="226"><span class="co">   to save and re-use the result the first time. We can use &quot;let-bindings&quot;: *)</span></a>
<a class="sourceLine" id="cb1-227" title="227"><span class="kw">fun</span> solve2 (a : <span class="dt">real</span>, b : <span class="dt">real</span>, c : <span class="dt">real</span>) =</a>
<a class="sourceLine" id="cb1-228" title="228">    <span class="kw">let</span> <span class="kw">val</span> discr  = b * b - <span class="fl">4.0</span> * a * c</a>
<a class="sourceLine" id="cb1-229" title="229">        <span class="kw">val</span> sqr = Math.<span class="dt">sqrt</span> discr</a>
<a class="sourceLine" id="cb1-230" title="230">        <span class="kw">val</span> denom = <span class="fl">2.0</span> * a</a>
<a class="sourceLine" id="cb1-231" title="231">    <span class="kw">in</span> ((~b + sqr) / denom,</a>
<a class="sourceLine" id="cb1-232" title="232">        (~b - sqr) / denom)</a>
<a class="sourceLine" id="cb1-233" title="233">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-234" title="234"></a>
<a class="sourceLine" id="cb1-235" title="235"></a>
<a class="sourceLine" id="cb1-236" title="236"><span class="co">(* Pattern matching is a funky part of functional programming.  It is an</span></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co">   alternative to if-sentences.  The fibonacci function can be rewritten: *)</span></a>
<a class="sourceLine" id="cb1-238" title="238"><span class="kw">fun</span> fibonacci <span class="dv">0</span> = <span class="dv">0</span>  <span class="co">(* Base case *)</span></a>
<a class="sourceLine" id="cb1-239" title="239">  | fibonacci <span class="dv">1</span> = <span class="dv">1</span>  <span class="co">(* Base case *)</span></a>
<a class="sourceLine" id="cb1-240" title="240">  | fibonacci n = fibonacci (n - <span class="dv">1</span>) + fibonacci (n - <span class="dv">2</span>)  <span class="co">(* Recursive case *)</span></a>
<a class="sourceLine" id="cb1-241" title="241"></a>
<a class="sourceLine" id="cb1-242" title="242"><span class="co">(* Pattern matching is also possible on composite types like tuples, lists and</span></a>
<a class="sourceLine" id="cb1-243" title="243"><span class="co">   records. Writing &quot;fun solve2 (a, b, c) = ...&quot; is in fact a pattern match on</span></a>
<a class="sourceLine" id="cb1-244" title="244"><span class="co">   the one three-tuple solve2 takes as argument. Similarly, but less intuitively,</span></a>
<a class="sourceLine" id="cb1-245" title="245"><span class="co">   you can match on a list consisting of elements in it (from the beginning of</span></a>
<a class="sourceLine" id="cb1-246" title="246"><span class="co">   the list only). *)</span></a>
<a class="sourceLine" id="cb1-247" title="247"><span class="kw">fun</span> first_elem (x::xs) = x</a>
<a class="sourceLine" id="cb1-248" title="248"><span class="kw">fun</span> second_elem (x::y::xs) = y</a>
<a class="sourceLine" id="cb1-249" title="249"><span class="kw">fun</span> evenly_positioned_elems (odd::even::xs) = even::evenly_positioned_elems xs</a>
<a class="sourceLine" id="cb1-250" title="250">  | evenly_positioned_elems [odd] = []  <span class="co">(* Base case: throw away *)</span></a>
<a class="sourceLine" id="cb1-251" title="251">  | evenly_positioned_elems []    = []  <span class="co">(* Base case *)</span></a>
<a class="sourceLine" id="cb1-252" title="252">  </a>
<a class="sourceLine" id="cb1-253" title="253"><span class="co">(* The case expression can also be used to pattern match and return a value *)</span></a>
<a class="sourceLine" id="cb1-254" title="254">datatype temp =</a>
<a class="sourceLine" id="cb1-255" title="255">      C <span class="kw">of</span> <span class="dt">real</span></a>
<a class="sourceLine" id="cb1-256" title="256">    | F <span class="kw">of</span> <span class="dt">real</span></a>
<a class="sourceLine" id="cb1-257" title="257">    </a>
<a class="sourceLine" id="cb1-258" title="258"><span class="co">(*  Declaring a new C temp value...</span></a>
<a class="sourceLine" id="cb1-259" title="259"><span class="co">    val t: temp = C 45.0  *)</span></a>
<a class="sourceLine" id="cb1-260" title="260"></a>
<a class="sourceLine" id="cb1-261" title="261"><span class="kw">fun</span> temp_to_f t =</a>
<a class="sourceLine" id="cb1-262" title="262">    case t <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-263" title="263">      C x =&gt; x * (<span class="fl">9.0</span> / <span class="fl">5.0</span>) + <span class="fl">32.0</span></a>
<a class="sourceLine" id="cb1-264" title="264">    | F x =&gt; x</a>
<a class="sourceLine" id="cb1-265" title="265"></a>
<a class="sourceLine" id="cb1-266" title="266"><span class="co">(* When matching on records, you must use their slot names, and you must bind</span></a>
<a class="sourceLine" id="cb1-267" title="267"><span class="co">   every slot in a record. The order of the slots doesn&#39;t matter though. *)</span></a>
<a class="sourceLine" id="cb1-268" title="268"></a>
<a class="sourceLine" id="cb1-269" title="269"><span class="kw">fun</span> rgbToTup {r, g, b} = (r, g, b)    <span class="co">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span></a>
<a class="sourceLine" id="cb1-270" title="270"><span class="kw">fun</span> mixRgbToTup {g, b, r} = (r, g, b) <span class="co">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span></a>
<a class="sourceLine" id="cb1-271" title="271"></a>
<a class="sourceLine" id="cb1-272" title="272"><span class="co">(* If called with {r=0.1, g=0.2, b=0.3}, either of the above functions</span></a>
<a class="sourceLine" id="cb1-273" title="273"><span class="co">   would return (0.1, 0.2, 0.3). But it would be a type error to call them</span></a>
<a class="sourceLine" id="cb1-274" title="274"><span class="co">   with {r=0.1, g=0.2, b=0.3, a=0.4} *)</span></a>
<a class="sourceLine" id="cb1-275" title="275"></a>
<a class="sourceLine" id="cb1-276" title="276"><span class="co">(* Higher order functions: Functions can take other functions as arguments.</span></a>
<a class="sourceLine" id="cb1-277" title="277"><span class="co">   Functions are just other kinds of values, and functions don&#39;t need names</span></a>
<a class="sourceLine" id="cb1-278" title="278"><span class="co">   to exist.  Functions without names are called &quot;anonymous functions&quot; or</span></a>
<a class="sourceLine" id="cb1-279" title="279"><span class="co">   lambda expressions or closures (since they also have a lexical scope). *)</span></a>
<a class="sourceLine" id="cb1-280" title="280"><span class="kw">val</span> is_large = (fn x =&gt; x &gt; <span class="dv">37</span>)</a>
<a class="sourceLine" id="cb1-281" title="281"><span class="kw">val</span> add_them = fn (a,b) =&gt; a + b</a>
<a class="sourceLine" id="cb1-282" title="282"><span class="kw">val</span> thermometer =</a>
<a class="sourceLine" id="cb1-283" title="283">    fn temp =&gt; <span class="kw">if</span> temp &lt; <span class="dv">37</span></a>
<a class="sourceLine" id="cb1-284" title="284">               <span class="kw">then</span> <span class="st">&quot;Cold&quot;</span></a>
<a class="sourceLine" id="cb1-285" title="285">               <span class="kw">else</span> <span class="kw">if</span> temp &gt; <span class="dv">37</span></a>
<a class="sourceLine" id="cb1-286" title="286">                    <span class="kw">then</span> <span class="st">&quot;Warm&quot;</span></a>
<a class="sourceLine" id="cb1-287" title="287">                    <span class="kw">else</span> <span class="st">&quot;Normal&quot;</span></a>
<a class="sourceLine" id="cb1-288" title="288"></a>
<a class="sourceLine" id="cb1-289" title="289"><span class="co">(* The following uses an anonymous function directly and gives &quot;ColdWarm&quot; *)</span></a>
<a class="sourceLine" id="cb1-290" title="290"><span class="kw">val</span> some_result = (fn x =&gt; thermometer (x - <span class="dv">5</span>) ^ thermometer (x + <span class="dv">5</span>)) <span class="dv">37</span></a>
<a class="sourceLine" id="cb1-291" title="291"></a>
<a class="sourceLine" id="cb1-292" title="292"><span class="co">(* Here is a higher-order function that works on lists (a list combinator) *)</span></a>
<a class="sourceLine" id="cb1-293" title="293"><span class="co">(* map f l</span></a>
<a class="sourceLine" id="cb1-294" title="294"><span class="co">       applies f to each element of l from left to right, </span></a>
<a class="sourceLine" id="cb1-295" title="295"><span class="co">       returning the list of results. *)</span></a>
<a class="sourceLine" id="cb1-296" title="296"><span class="kw">val</span> readings = [ <span class="dv">34</span>, <span class="dv">39</span>, <span class="dv">37</span>, <span class="dv">38</span>, <span class="dv">35</span>, <span class="dv">36</span>, <span class="dv">37</span>, <span class="dv">37</span>, <span class="dv">37</span> ]  <span class="co">(* first an int list *)</span></a>
<a class="sourceLine" id="cb1-297" title="297"><span class="kw">val</span> opinions = <span class="dt">List</span>.map thermometer readings <span class="co">(* gives [ &quot;Cold&quot;, &quot;Warm&quot;, ... ] *)</span></a>
<a class="sourceLine" id="cb1-298" title="298"></a>
<a class="sourceLine" id="cb1-299" title="299"><span class="co">(* And here is another one for filtering lists *)</span></a>
<a class="sourceLine" id="cb1-300" title="300"><span class="kw">val</span> warm_readings = <span class="dt">List</span>.filter is_large readings  <span class="co">(* gives [39, 38] *)</span></a>
<a class="sourceLine" id="cb1-301" title="301"></a>
<a class="sourceLine" id="cb1-302" title="302"><span class="co">(* You can create your own higher-order functions, too.  Functions can also take</span></a>
<a class="sourceLine" id="cb1-303" title="303"><span class="co">   several arguments by &quot;currying&quot; them. Syntax-wise this means adding spaces</span></a>
<a class="sourceLine" id="cb1-304" title="304"><span class="co">   between function arguments instead of commas and surrounding parentheses. *)</span></a>
<a class="sourceLine" id="cb1-305" title="305"><span class="kw">fun</span> map f [] = []</a>
<a class="sourceLine" id="cb1-306" title="306">  | map f (x::xs) = f(x) :: map f xs</a>
<a class="sourceLine" id="cb1-307" title="307"></a>
<a class="sourceLine" id="cb1-308" title="308"><span class="co">(* map has type (&#39;a -&gt; &#39;b) -&gt; &#39;a list -&gt; &#39;b list and is called polymorphic. *)</span></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">(* &#39;a is called a type variable. *)</span></a>
<a class="sourceLine" id="cb1-310" title="310"></a>
<a class="sourceLine" id="cb1-311" title="311"></a>
<a class="sourceLine" id="cb1-312" title="312"><span class="co">(* We can declare functions as infix *)</span></a>
<a class="sourceLine" id="cb1-313" title="313"><span class="kw">val</span> plus = add_them   <span class="co">(* plus is now equal to the same function as add_them *)</span></a>
<a class="sourceLine" id="cb1-314" title="314">infix plus            <span class="co">(* plus is now an infix operator *)</span></a>
<a class="sourceLine" id="cb1-315" title="315"><span class="kw">val</span> seven = <span class="dv">2</span> plus <span class="dv">5</span>  <span class="co">(* seven is now bound to 7 *)</span></a>
<a class="sourceLine" id="cb1-316" title="316"></a>
<a class="sourceLine" id="cb1-317" title="317"><span class="co">(* Functions can also be made infix before they are declared *)</span></a>
<a class="sourceLine" id="cb1-318" title="318">infix minus</a>
<a class="sourceLine" id="cb1-319" title="319"><span class="kw">fun</span> x minus y = x - y <span class="co">(* It becomes a little hard to see what&#39;s the argument *)</span></a>
<a class="sourceLine" id="cb1-320" title="320"><span class="kw">val</span> four = <span class="dv">8</span> minus <span class="dv">4</span>  <span class="co">(* four is now bound to 4 *)</span></a>
<a class="sourceLine" id="cb1-321" title="321"></a>
<a class="sourceLine" id="cb1-322" title="322"><span class="co">(* An infix function/operator can be made prefix with &#39;op&#39; *)</span></a>
<a class="sourceLine" id="cb1-323" title="323"><span class="kw">val</span> n = op + (<span class="dv">5</span>, <span class="dv">5</span>)   <span class="co">(* n is now 10 *)</span></a>
<a class="sourceLine" id="cb1-324" title="324"></a>
<a class="sourceLine" id="cb1-325" title="325"><span class="co">(* &#39;op&#39; is useful when combined with high order functions because they expect</span></a>
<a class="sourceLine" id="cb1-326" title="326"><span class="co">   functions and not operators as arguments. Most operators are really just</span></a>
<a class="sourceLine" id="cb1-327" title="327"><span class="co">   infix functions. *)</span></a>
<a class="sourceLine" id="cb1-328" title="328"><span class="co">(* foldl f init [x1, x2, ..., xn]</span></a>
<a class="sourceLine" id="cb1-329" title="329"><span class="co">       returns</span></a>
<a class="sourceLine" id="cb1-330" title="330"><span class="co">       f(xn, ...f(x2, f(x1, init))...)</span></a>
<a class="sourceLine" id="cb1-331" title="331"><span class="co">       or init if the list is empty. *)</span></a>
<a class="sourceLine" id="cb1-332" title="332"><span class="kw">val</span> sum_of_numbers = foldl op+ <span class="dv">0</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb1-333" title="333"></a>
<a class="sourceLine" id="cb1-334" title="334"></a>
<a class="sourceLine" id="cb1-335" title="335"><span class="co">(* Datatypes are useful for creating both simple and complex structures *)</span></a>
<a class="sourceLine" id="cb1-336" title="336">datatype color = Red | Green | Blue</a>
<a class="sourceLine" id="cb1-337" title="337"></a>
<a class="sourceLine" id="cb1-338" title="338"><span class="co">(* Here is a function that takes one of these as argument *)</span></a>
<a class="sourceLine" id="cb1-339" title="339"><span class="kw">fun</span> say(col) =</a>
<a class="sourceLine" id="cb1-340" title="340">    <span class="kw">if</span> col = Red <span class="kw">then</span> <span class="st">&quot;You are red!&quot;</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-341" title="341">    <span class="kw">if</span> col = Green <span class="kw">then</span> <span class="st">&quot;You are green!&quot;</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-342" title="342">    <span class="kw">if</span> col = Blue <span class="kw">then</span> <span class="st">&quot;You are blue!&quot;</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-343" title="343">    <span class="dt">raise</span> Fail <span class="st">&quot;Unknown color&quot;</span></a>
<a class="sourceLine" id="cb1-344" title="344"></a>
<a class="sourceLine" id="cb1-345" title="345"><span class="kw">val</span> _ = print (say(Red) ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-346" title="346"></a>
<a class="sourceLine" id="cb1-347" title="347"><span class="co">(* Datatypes are very often used in combination with pattern matching *)</span></a>
<a class="sourceLine" id="cb1-348" title="348"><span class="kw">fun</span> say Red   = <span class="st">&quot;You are red!&quot;</span></a>
<a class="sourceLine" id="cb1-349" title="349">  | say Green = <span class="st">&quot;You are green!&quot;</span></a>
<a class="sourceLine" id="cb1-350" title="350">  | say Blue  = <span class="st">&quot;You are blue!&quot;</span></a>
<a class="sourceLine" id="cb1-351" title="351"></a>
<a class="sourceLine" id="cb1-352" title="352"><span class="co">(* We did not include the match arm `say _ = raise Fail &quot;Unknown color&quot;`</span></a>
<a class="sourceLine" id="cb1-353" title="353"><span class="co">because after specifying all three colors, the pattern is exhaustive</span></a>
<a class="sourceLine" id="cb1-354" title="354"><span class="co">and redundancy is not permitted in pattern matching *)</span></a>
<a class="sourceLine" id="cb1-355" title="355"></a>
<a class="sourceLine" id="cb1-356" title="356"></a>
<a class="sourceLine" id="cb1-357" title="357"><span class="co">(* Here is a binary tree datatype *)</span></a>
<a class="sourceLine" id="cb1-358" title="358">datatype &#39;a btree = Leaf <span class="kw">of</span> &#39;a</a>
<a class="sourceLine" id="cb1-359" title="359">                  | Node <span class="kw">of</span> &#39;a btree * &#39;a * &#39;a btree <span class="co">(* three-arg constructor *)</span></a>
<a class="sourceLine" id="cb1-360" title="360"></a>
<a class="sourceLine" id="cb1-361" title="361"><span class="co">(* Here is a binary tree *)</span></a>
<a class="sourceLine" id="cb1-362" title="362"><span class="kw">val</span> myTree = Node (Leaf <span class="dv">9</span>, <span class="dv">8</span>, Node (Leaf <span class="dv">3</span>, <span class="dv">5</span>, Leaf <span class="dv">7</span>))</a>
<a class="sourceLine" id="cb1-363" title="363"></a>
<a class="sourceLine" id="cb1-364" title="364"><span class="co">(* Drawing it, it might look something like...</span></a>
<a class="sourceLine" id="cb1-365" title="365"></a>
<a class="sourceLine" id="cb1-366" title="366"><span class="co">           8</span></a>
<a class="sourceLine" id="cb1-367" title="367"><span class="co">          / \</span></a>
<a class="sourceLine" id="cb1-368" title="368"><span class="co"> leaf -&gt; 9   5</span></a>
<a class="sourceLine" id="cb1-369" title="369"><span class="co">            / \</span></a>
<a class="sourceLine" id="cb1-370" title="370"><span class="co">   leaf -&gt; 3   7 &lt;- leaf</span></a>
<a class="sourceLine" id="cb1-371" title="371"><span class="co"> *)</span></a>
<a class="sourceLine" id="cb1-372" title="372"></a>
<a class="sourceLine" id="cb1-373" title="373"><span class="co">(* This function counts the sum of all the elements in a tree *)</span></a>
<a class="sourceLine" id="cb1-374" title="374"><span class="kw">fun</span> count (Leaf n) = n</a>
<a class="sourceLine" id="cb1-375" title="375">  | count (Node (leftTree, n, rightTree)) = count leftTree + n + count rightTree</a>
<a class="sourceLine" id="cb1-376" title="376"></a>
<a class="sourceLine" id="cb1-377" title="377"><span class="kw">val</span> myTreeCount = count myTree  <span class="co">(* myTreeCount is now bound to 32 *)</span></a>
<a class="sourceLine" id="cb1-378" title="378"></a>
<a class="sourceLine" id="cb1-379" title="379"></a>
<a class="sourceLine" id="cb1-380" title="380"><span class="co">(* Exceptions! *)</span></a>
<a class="sourceLine" id="cb1-381" title="381"><span class="co">(* Exceptions can be raised/thrown using the reserved word &#39;raise&#39; *)</span></a>
<a class="sourceLine" id="cb1-382" title="382"><span class="kw">fun</span> calculate_interest(n) = <span class="kw">if</span> n &lt; <span class="fl">0.0</span></a>
<a class="sourceLine" id="cb1-383" title="383">                            <span class="kw">then</span> <span class="dt">raise</span> Domain</a>
<a class="sourceLine" id="cb1-384" title="384">                            <span class="kw">else</span> n * <span class="fl">1.04</span></a>
<a class="sourceLine" id="cb1-385" title="385"></a>
<a class="sourceLine" id="cb1-386" title="386"><span class="co">(* Exceptions can be caught using &quot;handle&quot; *)</span></a>
<a class="sourceLine" id="cb1-387" title="387"><span class="kw">val</span> balance = calculate_interest ~<span class="fl">180.0</span></a>
<a class="sourceLine" id="cb1-388" title="388">              handle Domain =&gt; ~<span class="fl">180.0</span>    <span class="co">(* balance now has the value ~180.0 *)</span></a>
<a class="sourceLine" id="cb1-389" title="389"></a>
<a class="sourceLine" id="cb1-390" title="390"><span class="co">(* Some exceptions carry extra information with them *)</span></a>
<a class="sourceLine" id="cb1-391" title="391"><span class="co">(* Here are some examples of built-in exceptions *)</span></a>
<a class="sourceLine" id="cb1-392" title="392"><span class="kw">fun</span> failing_function []    = <span class="dt">raise</span> Empty  <span class="co">(* used for empty lists *)</span></a>
<a class="sourceLine" id="cb1-393" title="393">  | failing_function [x]   = <span class="dt">raise</span> Fail <span class="st">&quot;This list is too short!&quot;</span></a>
<a class="sourceLine" id="cb1-394" title="394">  | failing_function [x,y] = <span class="dt">raise</span> Overflow  <span class="co">(* used for arithmetic *)</span></a>
<a class="sourceLine" id="cb1-395" title="395">  | failing_function xs    = <span class="dt">raise</span> Fail <span class="st">&quot;This list is too long!&quot;</span></a>
<a class="sourceLine" id="cb1-396" title="396"></a>
<a class="sourceLine" id="cb1-397" title="397"><span class="co">(* We can pattern match in &#39;handle&#39; to make sure</span></a>
<a class="sourceLine" id="cb1-398" title="398"><span class="co">   a specific exception was raised, or grab the message *)</span></a>
<a class="sourceLine" id="cb1-399" title="399"><span class="kw">val</span> err_msg = failing_function [<span class="dv">1</span>,<span class="dv">2</span>] handle Fail _ =&gt; <span class="st">&quot;Fail was raised&quot;</span></a>
<a class="sourceLine" id="cb1-400" title="400">                                          | Domain =&gt; <span class="st">&quot;Domain was raised&quot;</span></a>
<a class="sourceLine" id="cb1-401" title="401">                                          | Empty  =&gt; <span class="st">&quot;Empty was raised&quot;</span></a>
<a class="sourceLine" id="cb1-402" title="402">                                          | _      =&gt; <span class="st">&quot;Unknown exception&quot;</span></a>
<a class="sourceLine" id="cb1-403" title="403"></a>
<a class="sourceLine" id="cb1-404" title="404"><span class="co">(* err_msg now has the value &quot;Unknown exception&quot; because Overflow isn&#39;t</span></a>
<a class="sourceLine" id="cb1-405" title="405"><span class="co">   listed as one of the patterns -- thus, the catch-all pattern _ is used. *)</span></a>
<a class="sourceLine" id="cb1-406" title="406"></a>
<a class="sourceLine" id="cb1-407" title="407"><span class="co">(* We can define our own exceptions like this *)</span></a>
<a class="sourceLine" id="cb1-408" title="408"><span class="kw">exception</span> MyException</a>
<a class="sourceLine" id="cb1-409" title="409"><span class="kw">exception</span> MyExceptionWithMessage <span class="kw">of</span> <span class="dt">string</span></a>
<a class="sourceLine" id="cb1-410" title="410"><span class="kw">exception</span> SyntaxError <span class="kw">of</span> <span class="dt">string</span> * (<span class="dt">int</span> * <span class="dt">int</span>)</a>
<a class="sourceLine" id="cb1-411" title="411"></a>
<a class="sourceLine" id="cb1-412" title="412"><span class="co">(* File I/O! *)</span></a>
<a class="sourceLine" id="cb1-413" title="413"><span class="co">(* Write a nice poem to a file *)</span></a>
<a class="sourceLine" id="cb1-414" title="414"><span class="kw">fun</span> writePoem(filename) =</a>
<a class="sourceLine" id="cb1-415" title="415">    <span class="kw">let</span> <span class="kw">val</span> file = TextIO.openOut(filename)</a>
<a class="sourceLine" id="cb1-416" title="416">        <span class="kw">val</span> _ = TextIO.<span class="dt">output</span>(file, <span class="st">&quot;Roses are red,</span><span class="ch">\n</span><span class="st">Violets are blue.</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-417" title="417">        <span class="kw">val</span> _ = TextIO.<span class="dt">output</span>(file, <span class="st">&quot;I have a gun.</span><span class="ch">\n</span><span class="st">Get in the van.</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-418" title="418">    <span class="kw">in</span> TextIO.closeOut(file)</a>
<a class="sourceLine" id="cb1-419" title="419">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-420" title="420"></a>
<a class="sourceLine" id="cb1-421" title="421"><span class="co">(* Read a nice poem from a file into a list of strings *)</span></a>
<a class="sourceLine" id="cb1-422" title="422"><span class="kw">fun</span> readPoem(filename) =</a>
<a class="sourceLine" id="cb1-423" title="423">    <span class="kw">let</span> <span class="kw">val</span> file = TextIO.openIn filename</a>
<a class="sourceLine" id="cb1-424" title="424">        <span class="kw">val</span> poem = TextIO.inputAll file</a>
<a class="sourceLine" id="cb1-425" title="425">        <span class="kw">val</span> _ = TextIO.closeIn file</a>
<a class="sourceLine" id="cb1-426" title="426">    <span class="kw">in</span> <span class="dt">String</span>.tokens (fn c =&gt; c = #<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) poem</a>
<a class="sourceLine" id="cb1-427" title="427">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-428" title="428"></a>
<a class="sourceLine" id="cb1-429" title="429"><span class="kw">val</span> _ = writePoem <span class="st">&quot;roses.txt&quot;</span></a>
<a class="sourceLine" id="cb1-430" title="430"><span class="kw">val</span> test_poem = readPoem <span class="st">&quot;roses.txt&quot;</span>  <span class="co">(* gives [ &quot;Roses are red,&quot;,</span></a>
<a class="sourceLine" id="cb1-431" title="431"><span class="co">                                                 &quot;Violets are blue.&quot;,</span></a>
<a class="sourceLine" id="cb1-432" title="432"><span class="co">                                                 &quot;I have a gun.&quot;,</span></a>
<a class="sourceLine" id="cb1-433" title="433"><span class="co">                                                 &quot;Get in the van.&quot; ] *)</span></a>
<a class="sourceLine" id="cb1-434" title="434"></a>
<a class="sourceLine" id="cb1-435" title="435"><span class="co">(* We can create references to data which can be updated *)</span></a>
<a class="sourceLine" id="cb1-436" title="436"><span class="kw">val</span> counter = <span class="dt">ref</span> <span class="dv">0</span> <span class="co">(* Produce a reference with the ref function *)</span></a>
<a class="sourceLine" id="cb1-437" title="437"></a>
<a class="sourceLine" id="cb1-438" title="438"><span class="co">(* Assign to a reference with the assignment operator *)</span></a>
<a class="sourceLine" id="cb1-439" title="439"><span class="kw">fun</span> set_five reference = reference := <span class="dv">5</span></a>
<a class="sourceLine" id="cb1-440" title="440"></a>
<a class="sourceLine" id="cb1-441" title="441"><span class="co">(* Read a reference with the dereference operator *)</span></a>
<a class="sourceLine" id="cb1-442" title="442"><span class="kw">fun</span> equals_five reference = !reference = <span class="dv">5</span></a>
<a class="sourceLine" id="cb1-443" title="443"></a>
<a class="sourceLine" id="cb1-444" title="444"><span class="co">(* We can use while loops for when recursion is messy *)</span></a>
<a class="sourceLine" id="cb1-445" title="445"><span class="kw">fun</span> decrement_to_zero r = <span class="kw">if</span> !r &lt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-446" title="446">                          <span class="kw">then</span> r := <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-447" title="447">                          <span class="kw">else</span> <span class="kw">while</span> !r &gt;= <span class="dv">0</span> <span class="kw">do</span> r := !r - <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-448" title="448"></a>
<a class="sourceLine" id="cb1-449" title="449"><span class="co">(* This returns the unit value (in practical terms, nothing, a 0-tuple) *)</span></a>
<a class="sourceLine" id="cb1-450" title="450"></a>
<a class="sourceLine" id="cb1-451" title="451"><span class="co">(* To allow returning a value, we can use the semicolon to sequence evaluations *)</span></a>
<a class="sourceLine" id="cb1-452" title="452"><span class="kw">fun</span> decrement_ret x y = (x := !x - <span class="dv">1</span>; y)</a></code></pre></div>
<h2 id="further-learning">Further learning</h2>
<ul>
<li>Install an interactive compiler (REPL), for example <a href="http://www.polyml.org/">Poly/ML</a>, <a href="http://mosml.org">Moscow ML</a>, <a href="http://smlnj.org/">SML/NJ</a>.</li>
<li>Follow the Coursera course <a href="https://www.coursera.org/course/proglang">Programming Languages</a>.</li>
<li>Read <em><a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">ML for the Working Programmer</a></em> by Larry C. Paulson.</li>
<li>Use <a href="http://stackoverflow.com/questions/tagged/sml">StackOverflow’s sml tag</a>.</li>
<li>Solve exercises on <a href="https://exercism.io/tracks/sml">Exercism.io’s Standard ML track</a>.</li>
</ul>
</body>
</html>
