<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>clojure.html</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>Clojure is a Lisp family language developed for the Java Virtual Machine. It has a much stronger emphasis on pure <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> than Common Lisp, but includes several <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">STM</a> utilities to handle state as it comes up.</p>
<p>This combination allows it to handle concurrent processing very simply, and often automatically.</p>
<p>(You need a version of Clojure 1.2 or newer)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb1-1" title="1"><span class="co">; Comments start with semicolons.</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">; Clojure is written in &quot;forms&quot;, which are just</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">; lists of things inside parentheses, separated by whitespace.</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">; The clojure reader assumes that the first thing is a</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">; function or macro to call, and the rest are arguments.</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">; The first call in a file should be ns, to set the namespace</span></a>
<a class="sourceLine" id="cb1-10" title="10">(<span class="kw">ns</span> learnclojure)</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">; More basic examples:</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">; str will create a string out of all its arguments</span></a>
<a class="sourceLine" id="cb1-15" title="15">(<span class="kw">str</span> <span class="st">&quot;Hello&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;World&quot;</span>) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">; Math is straightforward</span></a>
<a class="sourceLine" id="cb1-18" title="18">(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-19" title="19">(<span class="kw">-</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-20" title="20">(<span class="kw">*</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-21" title="21">(<span class="kw">/</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">; Equality is =</span></a>
<a class="sourceLine" id="cb1-24" title="24">(<span class="kw">=</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-25" title="25">(<span class="kw">=</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">; You need not for logic, too</span></a>
<a class="sourceLine" id="cb1-28" title="28">(<span class="kw">not</span> <span class="va">true</span>) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">; Nesting forms works as you expect</span></a>
<a class="sourceLine" id="cb1-31" title="31">(<span class="kw">+</span> <span class="dv">1</span> (<span class="kw">-</span> <span class="dv">3</span> <span class="dv">2</span>)) <span class="co">; = 1 + (3 - 2) =&gt; 2</span></a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">; Types</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">; Clojure uses Java&#39;s object types for booleans, strings and numbers.</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">; Use `class` to inspect them.</span></a>
<a class="sourceLine" id="cb1-38" title="38">(<span class="kw">class</span> <span class="dv">1</span>) <span class="co">; Integer literals are java.lang.Long by default</span></a>
<a class="sourceLine" id="cb1-39" title="39">(<span class="kw">class</span> <span class="fl">1.</span>)<span class="co">; Float literals are java.lang.Double</span></a>
<a class="sourceLine" id="cb1-40" title="40">(<span class="kw">class</span> <span class="st">&quot;&quot;</span>)<span class="co">; Strings always double-quoted, and are java.lang.String</span></a>
<a class="sourceLine" id="cb1-41" title="41">(<span class="kw">class</span> <span class="va">false</span>) <span class="co">; Booleans are java.lang.Boolean</span></a>
<a class="sourceLine" id="cb1-42" title="42">(<span class="kw">class</span> <span class="va">nil</span>)<span class="co">; The &quot;null&quot; value is called nil</span></a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">; If you want to create a literal list of data, use &#39; to stop it from</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">; being evaluated</span></a>
<a class="sourceLine" id="cb1-46" title="46">&#39;(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; =&gt; (+ 1 2)</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">; (shorthand for (quote (+ 1 2)))</span></a>
<a class="sourceLine" id="cb1-48" title="48"></a>
<a class="sourceLine" id="cb1-49" title="49"><span class="co">; You can eval a quoted list</span></a>
<a class="sourceLine" id="cb1-50" title="50">(<span class="kw">eval</span> &#39;(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; =&gt; 3</span></a>
<a class="sourceLine" id="cb1-51" title="51"></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="co">; Collections &amp; Sequences</span></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co">;;;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-54" title="54"></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="co">; Lists are linked-list data structures, while Vectors are array-backed.</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="co">; Vectors and Lists are java classes too!</span></a>
<a class="sourceLine" id="cb1-57" title="57">(<span class="kw">class</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])<span class="co">; =&gt; clojure.lang.PersistentVector</span></a>
<a class="sourceLine" id="cb1-58" title="58">(<span class="kw">class</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))<span class="co">; =&gt; clojure.lang.PersistentList</span></a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="co">; A list would be written as just (1 2 3), but we have to quote</span></a>
<a class="sourceLine" id="cb1-61" title="61"><span class="co">; it to stop the reader thinking it&#39;s a function.</span></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="co">; Also, (list 1 2 3) is the same as &#39;(1 2 3)</span></a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64"><span class="co">; &quot;Collections&quot; are just groups of data</span></a>
<a class="sourceLine" id="cb1-65" title="65"><span class="co">; Both lists and vectors are collections:</span></a>
<a class="sourceLine" id="cb1-66" title="66">(<span class="kw">coll?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-67" title="67">(<span class="kw">coll?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="co">; &quot;Sequences&quot; (seqs) are abstract descriptions of lists of data.</span></a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co">; Only lists are seqs.</span></a>
<a class="sourceLine" id="cb1-71" title="71">(<span class="kw">seq?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-72" title="72">(<span class="kw">seq?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">; A seq need only provide an entry when it is accessed.</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">; So, seqs which can be lazy -- they can define infinite series:</span></a>
<a class="sourceLine" id="cb1-76" title="76">(<span class="kw">range</span> <span class="dv">4</span>) <span class="co">; =&gt; (0 1 2 3)</span></a>
<a class="sourceLine" id="cb1-77" title="77">(<span class="kw">range</span>) <span class="co">; =&gt; (0 1 2 3 4 ...) (an infinite series)</span></a>
<a class="sourceLine" id="cb1-78" title="78">(<span class="kw">take</span> <span class="dv">4</span> (<span class="kw">range</span>)) <span class="co">;  (0 1 2 3)</span></a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">; Use cons to add an item to the beginning of a list or vector</span></a>
<a class="sourceLine" id="cb1-81" title="81">(<span class="kw">cons</span> <span class="dv">4</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-82" title="82">(<span class="kw">cons</span> <span class="dv">4</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="co">; Conj will add an item to a collection in the most efficient way.</span></a>
<a class="sourceLine" id="cb1-85" title="85"><span class="co">; For lists, they insert at the beginning. For vectors, they insert at the end.</span></a>
<a class="sourceLine" id="cb1-86" title="86">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>) <span class="co">; =&gt; [1 2 3 4]</span></a>
<a class="sourceLine" id="cb1-87" title="87">(<span class="kw">conj</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="dv">4</span>) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-88" title="88"></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="co">; Use concat to add lists or vectors together</span></a>
<a class="sourceLine" id="cb1-90" title="90">(<span class="kw">concat</span> [<span class="dv">1</span> <span class="dv">2</span>] &#39;(<span class="dv">3</span> <span class="dv">4</span>)) <span class="co">; =&gt; (1 2 3 4)</span></a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="co">; Use filter, map to interact with collections</span></a>
<a class="sourceLine" id="cb1-93" title="93">(<span class="kw">map</span> <span class="kw">inc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (2 3 4)</span></a>
<a class="sourceLine" id="cb1-94" title="94">(<span class="kw">filter</span> <span class="kw">even?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (2)</span></a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="co">; Use reduce to reduce them</span></a>
<a class="sourceLine" id="cb1-97" title="97">(<span class="kw">reduce</span> <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])</a>
<a class="sourceLine" id="cb1-98" title="98"><span class="co">; = (+ (+ (+ 1 2) 3) 4)</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="co">; =&gt; 10</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="co">; Reduce can take an initial-value argument too</span></a>
<a class="sourceLine" id="cb1-102" title="102">(<span class="kw">reduce</span> <span class="kw">conj</span> [] &#39;(<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb1-103" title="103"><span class="co">; = (conj (conj (conj [] 3) 2) 1)</span></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="co">; =&gt; [3 2 1]</span></a>
<a class="sourceLine" id="cb1-105" title="105"></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="co">; Functions</span></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="co">;;;;;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-108" title="108"></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="co">; Use fn to create new functions. A function always returns</span></a>
<a class="sourceLine" id="cb1-110" title="110"><span class="co">; its last statement.</span></a>
<a class="sourceLine" id="cb1-111" title="111">(<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>) <span class="co">; =&gt; fn</span></a>
<a class="sourceLine" id="cb1-112" title="112"></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="co">; (You need extra parens to call it)</span></a>
<a class="sourceLine" id="cb1-114" title="114">((<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>)) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-115" title="115"></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="co">; You can create a var using def</span></a>
<a class="sourceLine" id="cb1-117" title="117">(<span class="bu">def</span><span class="fu"> x </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-118" title="118">x <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-119" title="119"></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="co">; Assign a function to a var</span></a>
<a class="sourceLine" id="cb1-121" title="121">(<span class="bu">def</span><span class="fu"> hello-world </span>(<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>))</a>
<a class="sourceLine" id="cb1-122" title="122">(hello-world) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-123" title="123"></a>
<a class="sourceLine" id="cb1-124" title="124"><span class="co">; You can shorten this process by using defn</span></a>
<a class="sourceLine" id="cb1-125" title="125">(<span class="bu">defn</span><span class="fu"> hello-world </span>[] <span class="st">&quot;Hello World&quot;</span>)</a>
<a class="sourceLine" id="cb1-126" title="126"></a>
<a class="sourceLine" id="cb1-127" title="127"><span class="co">; The [] is the list of arguments for the function.</span></a>
<a class="sourceLine" id="cb1-128" title="128">(<span class="bu">defn</span><span class="fu"> hello </span>[<span class="kw">name</span>]</a>
<a class="sourceLine" id="cb1-129" title="129">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>))</a>
<a class="sourceLine" id="cb1-130" title="130">(hello <span class="st">&quot;Steve&quot;</span>) <span class="co">; =&gt; &quot;Hello Steve&quot;</span></a>
<a class="sourceLine" id="cb1-131" title="131"></a>
<a class="sourceLine" id="cb1-132" title="132"><span class="co">; You can also use this shorthand to create functions:</span></a>
<a class="sourceLine" id="cb1-133" title="133">(<span class="bu">def</span><span class="fu"> hello2 </span>#(<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="va">%1</span>))</a>
<a class="sourceLine" id="cb1-134" title="134">(hello2 <span class="st">&quot;Julie&quot;</span>) <span class="co">; =&gt; &quot;Hello Julie&quot;</span></a>
<a class="sourceLine" id="cb1-135" title="135"></a>
<a class="sourceLine" id="cb1-136" title="136"><span class="co">; You can have multi-variadic functions, too</span></a>
<a class="sourceLine" id="cb1-137" title="137">(<span class="bu">defn</span><span class="fu"> hello3</span></a>
<a class="sourceLine" id="cb1-138" title="138">  ([] <span class="st">&quot;Hello World&quot;</span>)</a>
<a class="sourceLine" id="cb1-139" title="139">  ([<span class="kw">name</span>] (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>)))</a>
<a class="sourceLine" id="cb1-140" title="140">(hello3 <span class="st">&quot;Jake&quot;</span>) <span class="co">; =&gt; &quot;Hello Jake&quot;</span></a>
<a class="sourceLine" id="cb1-141" title="141">(hello3) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-142" title="142"></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="co">; Functions can pack extra arguments up in a seq for you</span></a>
<a class="sourceLine" id="cb1-144" title="144">(<span class="bu">defn</span><span class="fu"> count-args </span>[&amp; args]</a>
<a class="sourceLine" id="cb1-145" title="145">  (<span class="kw">str</span> <span class="st">&quot;You passed &quot;</span> (<span class="kw">count</span> args) <span class="st">&quot; args: &quot;</span> args))</a>
<a class="sourceLine" id="cb1-146" title="146">(count-args <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; =&gt; &quot;You passed 3 args: (1 2 3)&quot;</span></a>
<a class="sourceLine" id="cb1-147" title="147"></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">; You can mix regular and packed arguments</span></a>
<a class="sourceLine" id="cb1-149" title="149">(<span class="bu">defn</span><span class="fu"> hello-count </span>[<span class="kw">name</span> &amp; args]</a>
<a class="sourceLine" id="cb1-150" title="150">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span> <span class="st">&quot;, you passed &quot;</span> (<span class="kw">count</span> args) <span class="st">&quot; extra args&quot;</span>))</a>
<a class="sourceLine" id="cb1-151" title="151">(hello-count <span class="st">&quot;Finn&quot;</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-152" title="152"><span class="co">; =&gt; &quot;Hello Finn, you passed 3 extra args&quot;</span></a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154"></a>
<a class="sourceLine" id="cb1-155" title="155"><span class="co">; Maps</span></a>
<a class="sourceLine" id="cb1-156" title="156"><span class="co">;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158"><span class="co">; Hash maps and array maps share an interface. Hash maps have faster lookups</span></a>
<a class="sourceLine" id="cb1-159" title="159"><span class="co">; but don&#39;t retain key order.</span></a>
<a class="sourceLine" id="cb1-160" title="160">(<span class="kw">class</span> {<span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span> <span class="at">:c</span> <span class="dv">3</span>}) <span class="co">; =&gt; clojure.lang.PersistentArrayMap</span></a>
<a class="sourceLine" id="cb1-161" title="161">(<span class="kw">class</span> (<span class="kw">hash-map</span> <span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span> <span class="at">:c</span> <span class="dv">3</span>)) <span class="co">; =&gt; clojure.lang.PersistentHashMap</span></a>
<a class="sourceLine" id="cb1-162" title="162"></a>
<a class="sourceLine" id="cb1-163" title="163"><span class="co">; Arraymaps will automatically become hashmaps through most operations</span></a>
<a class="sourceLine" id="cb1-164" title="164"><span class="co">; if they get big enough, so you don&#39;t need to worry.</span></a>
<a class="sourceLine" id="cb1-165" title="165"></a>
<a class="sourceLine" id="cb1-166" title="166"><span class="co">; Maps can use any hashable type as a key, but usually keywords are best</span></a>
<a class="sourceLine" id="cb1-167" title="167"><span class="co">; Keywords are like strings with some efficiency bonuses</span></a>
<a class="sourceLine" id="cb1-168" title="168">(<span class="kw">class</span> <span class="at">:a</span>) <span class="co">; =&gt; clojure.lang.Keyword</span></a>
<a class="sourceLine" id="cb1-169" title="169"></a>
<a class="sourceLine" id="cb1-170" title="170">(<span class="bu">def</span><span class="fu"> stringmap </span>{<span class="st">&quot;a&quot;</span> <span class="dv">1</span>, <span class="st">&quot;b&quot;</span> <span class="dv">2</span>, <span class="st">&quot;c&quot;</span> <span class="dv">3</span>})</a>
<a class="sourceLine" id="cb1-171" title="171">stringmap  <span class="co">; =&gt; {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}</span></a>
<a class="sourceLine" id="cb1-172" title="172"></a>
<a class="sourceLine" id="cb1-173" title="173">(<span class="bu">def</span><span class="fu"> keymap </span>{<span class="at">:a</span> <span class="dv">1</span>, <span class="at">:b</span> <span class="dv">2</span>, <span class="at">:c</span> <span class="dv">3</span>})</a>
<a class="sourceLine" id="cb1-174" title="174">keymap <span class="co">; =&gt; {:a 1, :c 3, :b 2}</span></a>
<a class="sourceLine" id="cb1-175" title="175"></a>
<a class="sourceLine" id="cb1-176" title="176"><span class="co">; By the way, commas are always treated as whitespace and do nothing.</span></a>
<a class="sourceLine" id="cb1-177" title="177"></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co">; Retrieve a value from a map by calling it as a function</span></a>
<a class="sourceLine" id="cb1-179" title="179">(stringmap <span class="st">&quot;a&quot;</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-180" title="180">(keymap <span class="at">:a</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-181" title="181"></a>
<a class="sourceLine" id="cb1-182" title="182"><span class="co">; Keywords can be used to retrieve their value from a map, too!</span></a>
<a class="sourceLine" id="cb1-183" title="183">(<span class="at">:b</span> keymap) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">; Don&#39;t try this with strings.</span></a>
<a class="sourceLine" id="cb1-186" title="186"><span class="co">;(&quot;a&quot; stringmap)</span></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="co">; =&gt; Exception: java.lang.String cannot be cast to clojure.lang.IFn</span></a>
<a class="sourceLine" id="cb1-188" title="188"></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">; Retrieving a non-present key returns nil</span></a>
<a class="sourceLine" id="cb1-190" title="190">(stringmap <span class="st">&quot;d&quot;</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-191" title="191"></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="co">; Use assoc to add new keys to hash-maps</span></a>
<a class="sourceLine" id="cb1-193" title="193">(<span class="bu">def</span><span class="fu"> newkeymap </span>(<span class="kw">assoc</span> keymap <span class="at">:d</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb1-194" title="194">newkeymap <span class="co">; =&gt; {:a 1, :b 2, :c 3, :d 4}</span></a>
<a class="sourceLine" id="cb1-195" title="195"></a>
<a class="sourceLine" id="cb1-196" title="196"><span class="co">; But remember, clojure types are immutable!</span></a>
<a class="sourceLine" id="cb1-197" title="197">keymap <span class="co">; =&gt; {:a 1, :b 2, :c 3}</span></a>
<a class="sourceLine" id="cb1-198" title="198"></a>
<a class="sourceLine" id="cb1-199" title="199"><span class="co">; Use dissoc to remove keys</span></a>
<a class="sourceLine" id="cb1-200" title="200">(<span class="kw">dissoc</span> keymap <span class="at">:a</span> <span class="at">:b</span>) <span class="co">; =&gt; {:c 3}</span></a>
<a class="sourceLine" id="cb1-201" title="201"></a>
<a class="sourceLine" id="cb1-202" title="202"><span class="co">; Sets</span></a>
<a class="sourceLine" id="cb1-203" title="203"><span class="co">;;;;;;</span></a>
<a class="sourceLine" id="cb1-204" title="204"></a>
<a class="sourceLine" id="cb1-205" title="205">(<span class="kw">class</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>}) <span class="co">; =&gt; clojure.lang.PersistentHashSet</span></a>
<a class="sourceLine" id="cb1-206" title="206">(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">; =&gt; #{1 2 3}</span></a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208"><span class="co">; Add a member with conj</span></a>
<a class="sourceLine" id="cb1-209" title="209">(<span class="kw">conj</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">4</span>) <span class="co">; =&gt; #{1 2 3 4}</span></a>
<a class="sourceLine" id="cb1-210" title="210"></a>
<a class="sourceLine" id="cb1-211" title="211"><span class="co">; Remove one with disj</span></a>
<a class="sourceLine" id="cb1-212" title="212">(<span class="kw">disj</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">1</span>) <span class="co">; =&gt; #{2 3}</span></a>
<a class="sourceLine" id="cb1-213" title="213"></a>
<a class="sourceLine" id="cb1-214" title="214"><span class="co">; Test for existence by using the set as a function:</span></a>
<a class="sourceLine" id="cb1-215" title="215">(#{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">1</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-216" title="216">(#{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">4</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-217" title="217"></a>
<a class="sourceLine" id="cb1-218" title="218"><span class="co">; There are more functions in the clojure.sets namespace.</span></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220"><span class="co">; Useful forms</span></a>
<a class="sourceLine" id="cb1-221" title="221"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-222" title="222"></a>
<a class="sourceLine" id="cb1-223" title="223"><span class="co">; Logic constructs in clojure are just macros, and look like</span></a>
<a class="sourceLine" id="cb1-224" title="224"><span class="co">; everything else</span></a>
<a class="sourceLine" id="cb1-225" title="225">(<span class="kw">if</span> <span class="va">false</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>) <span class="co">; =&gt; &quot;b&quot;</span></a>
<a class="sourceLine" id="cb1-226" title="226">(<span class="kw">if</span> <span class="va">false</span> <span class="st">&quot;a&quot;</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-227" title="227"></a>
<a class="sourceLine" id="cb1-228" title="228"><span class="co">; Use let to create temporary bindings</span></a>
<a class="sourceLine" id="cb1-229" title="229">(<span class="kw">let</span> [a <span class="dv">1</span> b <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb1-230" title="230">  (<span class="kw">&gt;</span> a b)) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-231" title="231"></a>
<a class="sourceLine" id="cb1-232" title="232"><span class="co">; Group statements together with do</span></a>
<a class="sourceLine" id="cb1-233" title="233">(<span class="kw">do</span></a>
<a class="sourceLine" id="cb1-234" title="234">  (<span class="kw">print</span> <span class="st">&quot;Hello&quot;</span>)</a>
<a class="sourceLine" id="cb1-235" title="235">  <span class="st">&quot;World&quot;</span>) <span class="co">; =&gt; &quot;World&quot; (prints &quot;Hello&quot;)</span></a>
<a class="sourceLine" id="cb1-236" title="236"></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co">; Functions have an implicit do</span></a>
<a class="sourceLine" id="cb1-238" title="238">(<span class="bu">defn</span><span class="fu"> print-and-say-hello </span>[<span class="kw">name</span>]</a>
<a class="sourceLine" id="cb1-239" title="239">  (<span class="kw">print</span> <span class="st">&quot;Saying hello to &quot;</span> <span class="kw">name</span>)</a>
<a class="sourceLine" id="cb1-240" title="240">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>))</a>
<a class="sourceLine" id="cb1-241" title="241">(print-and-say-hello <span class="st">&quot;Jeff&quot;</span>) <span class="co">;=&gt; &quot;Hello Jeff&quot; (prints &quot;Saying hello to Jeff&quot;)</span></a>
<a class="sourceLine" id="cb1-242" title="242"></a>
<a class="sourceLine" id="cb1-243" title="243"><span class="co">; So does let</span></a>
<a class="sourceLine" id="cb1-244" title="244">(<span class="kw">let</span> [<span class="kw">name</span> <span class="st">&quot;Urkel&quot;</span>]</a>
<a class="sourceLine" id="cb1-245" title="245">  (<span class="kw">print</span> <span class="st">&quot;Saying hello to &quot;</span> <span class="kw">name</span>)</a>
<a class="sourceLine" id="cb1-246" title="246">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>)) <span class="co">; =&gt; &quot;Hello Urkel&quot; (prints &quot;Saying hello to Urkel&quot;)</span></a>
<a class="sourceLine" id="cb1-247" title="247"></a>
<a class="sourceLine" id="cb1-248" title="248"></a>
<a class="sourceLine" id="cb1-249" title="249"><span class="co">; Use the threading macros (-&gt; and -&gt;&gt;) to express transformations of</span></a>
<a class="sourceLine" id="cb1-250" title="250"><span class="co">; data more clearly.</span></a>
<a class="sourceLine" id="cb1-251" title="251"></a>
<a class="sourceLine" id="cb1-252" title="252"><span class="co">; The &quot;Thread-first&quot; macro (-&gt;) inserts into each form the result of</span></a>
<a class="sourceLine" id="cb1-253" title="253"><span class="co">; the previous, as the first argument (second item)</span></a>
<a class="sourceLine" id="cb1-254" title="254">(<span class="kw">-&gt;</span>  </a>
<a class="sourceLine" id="cb1-255" title="255">   {<span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span>} </a>
<a class="sourceLine" id="cb1-256" title="256">   (<span class="kw">assoc</span> <span class="at">:c</span> <span class="dv">3</span>) <span class="co">;=&gt; (assoc {:a 1 :b 2} :c 3)</span></a>
<a class="sourceLine" id="cb1-257" title="257">   (<span class="kw">dissoc</span> <span class="at">:b</span>)) <span class="co">;=&gt; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span></a>
<a class="sourceLine" id="cb1-258" title="258"></a>
<a class="sourceLine" id="cb1-259" title="259"><span class="co">; This expression could be written as:</span></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span></a>
<a class="sourceLine" id="cb1-261" title="261"><span class="co">; and evaluates to {:a 1 :c 3}</span></a>
<a class="sourceLine" id="cb1-262" title="262"></a>
<a class="sourceLine" id="cb1-263" title="263"><span class="co">; The double arrow does the same thing, but inserts the result of</span></a>
<a class="sourceLine" id="cb1-264" title="264"><span class="co">; each line at the *end* of the form. This is useful for collection</span></a>
<a class="sourceLine" id="cb1-265" title="265"><span class="co">; operations in particular:</span></a>
<a class="sourceLine" id="cb1-266" title="266">(<span class="kw">-&gt;&gt;</span></a>
<a class="sourceLine" id="cb1-267" title="267">   (<span class="kw">range</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1-268" title="268">   (<span class="kw">map</span> <span class="kw">inc</span>)     <span class="co">;=&gt; (map inc (range 10)</span></a>
<a class="sourceLine" id="cb1-269" title="269">   (<span class="kw">filter</span> <span class="kw">odd?</span>) <span class="co">;=&gt; (filter odd? (map inc (range 10))</span></a>
<a class="sourceLine" id="cb1-270" title="270">   (<span class="kw">into</span> []))    <span class="co">;=&gt; (into [] (filter odd? (map inc (range 10)))</span></a>
<a class="sourceLine" id="cb1-271" title="271">                 <span class="co">; Result: [1 3 5 7 9]</span></a>
<a class="sourceLine" id="cb1-272" title="272"></a>
<a class="sourceLine" id="cb1-273" title="273"><span class="co">; When you are in a situation where you want more freedom as where to</span></a>
<a class="sourceLine" id="cb1-274" title="274"><span class="co">; put the result of previous data transformations in an </span></a>
<a class="sourceLine" id="cb1-275" title="275"><span class="co">; expression, you can use the as-&gt; macro. With it, you can assign a</span></a>
<a class="sourceLine" id="cb1-276" title="276"><span class="co">; specific name to transformations&#39; output and use it as a</span></a>
<a class="sourceLine" id="cb1-277" title="277"><span class="co">; placeholder in your chained expressions:</span></a>
<a class="sourceLine" id="cb1-278" title="278"></a>
<a class="sourceLine" id="cb1-279" title="279">(<span class="kw">as-&gt;</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] input</a>
<a class="sourceLine" id="cb1-280" title="280">  (<span class="kw">map</span> <span class="kw">inc</span> input)<span class="co">;=&gt; You can use last transform&#39;s output at the last position</span></a>
<a class="sourceLine" id="cb1-281" title="281">  (<span class="kw">nth</span> input <span class="dv">2</span>) <span class="co">;=&gt;  and at the second position, in the same expression</span></a>
<a class="sourceLine" id="cb1-282" title="282">  (<span class="kw">conj</span> [<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>] input <span class="dv">8</span> <span class="dv">9</span> <span class="dv">10</span>)) <span class="co">;=&gt; or in the middle !</span></a>
<a class="sourceLine" id="cb1-283" title="283">                               <span class="co">; Result: [4 5 6 4 8 9 10]</span></a>
<a class="sourceLine" id="cb1-284" title="284"></a>
<a class="sourceLine" id="cb1-285" title="285"></a>
<a class="sourceLine" id="cb1-286" title="286"><span class="co">; Modules</span></a>
<a class="sourceLine" id="cb1-287" title="287"><span class="co">;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-288" title="288"></a>
<a class="sourceLine" id="cb1-289" title="289"><span class="co">; Use &quot;use&quot; to get all functions from the module</span></a>
<a class="sourceLine" id="cb1-290" title="290">(<span class="kw">use</span> <span class="at">&#39;clojure.set</span>)</a>
<a class="sourceLine" id="cb1-291" title="291"></a>
<a class="sourceLine" id="cb1-292" title="292"><span class="co">; Now we can use set operations</span></a>
<a class="sourceLine" id="cb1-293" title="293">(<span class="kw">intersection</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>}) <span class="co">; =&gt; #{2 3}</span></a>
<a class="sourceLine" id="cb1-294" title="294">(<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>}) <span class="co">; =&gt; #{1}</span></a>
<a class="sourceLine" id="cb1-295" title="295"></a>
<a class="sourceLine" id="cb1-296" title="296"><span class="co">; You can choose a subset of functions to import, too</span></a>
<a class="sourceLine" id="cb1-297" title="297">(<span class="kw">use</span> &#39;[clojure.<span class="kw">set</span> <span class="at">:only</span> [<span class="kw">intersection</span>]])</a>
<a class="sourceLine" id="cb1-298" title="298"></a>
<a class="sourceLine" id="cb1-299" title="299"><span class="co">; Use require to import a module</span></a>
<a class="sourceLine" id="cb1-300" title="300">(<span class="kw">require</span> <span class="at">&#39;clojure.string</span>)</a>
<a class="sourceLine" id="cb1-301" title="301"></a>
<a class="sourceLine" id="cb1-302" title="302"><span class="co">; Use / to call functions from a module</span></a>
<a class="sourceLine" id="cb1-303" title="303"><span class="co">; Here, the module is clojure.string and the function is blank?</span></a>
<a class="sourceLine" id="cb1-304" title="304">(clojure.string/blank? <span class="st">&quot;&quot;</span>) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-305" title="305"></a>
<a class="sourceLine" id="cb1-306" title="306"><span class="co">; You can give a module a shorter name on import</span></a>
<a class="sourceLine" id="cb1-307" title="307">(<span class="kw">require</span> &#39;[clojure.string <span class="at">:as</span> <span class="kw">str</span>])</a>
<a class="sourceLine" id="cb1-308" title="308">(str/replace <span class="st">&quot;This is a test.&quot;</span> <span class="ss">#&quot;[a-o]&quot;</span> str/upper-case) <span class="co">; =&gt; &quot;THIs Is A tEst.&quot;</span></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">; (#&quot;&quot; denotes a regular expression literal)</span></a>
<a class="sourceLine" id="cb1-310" title="310"></a>
<a class="sourceLine" id="cb1-311" title="311"><span class="co">; You can use require (and use, but don&#39;t) from a namespace using :require.</span></a>
<a class="sourceLine" id="cb1-312" title="312"><span class="co">; You don&#39;t need to quote your modules if you do it this way.</span></a>
<a class="sourceLine" id="cb1-313" title="313">(<span class="kw">ns</span> <span class="kw">test</span></a>
<a class="sourceLine" id="cb1-314" title="314">  (<span class="at">:require</span></a>
<a class="sourceLine" id="cb1-315" title="315">    [clojure.string <span class="at">:as</span> <span class="kw">str</span>]</a>
<a class="sourceLine" id="cb1-316" title="316">    [clojure.<span class="kw">set</span> <span class="at">:as</span> <span class="kw">set</span>]))</a>
<a class="sourceLine" id="cb1-317" title="317"></a>
<a class="sourceLine" id="cb1-318" title="318"><span class="co">; Java</span></a>
<a class="sourceLine" id="cb1-319" title="319"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-320" title="320"></a>
<a class="sourceLine" id="cb1-321" title="321"><span class="co">; Java has a huge and useful standard library, so</span></a>
<a class="sourceLine" id="cb1-322" title="322"><span class="co">; you&#39;ll want to learn how to get at it.</span></a>
<a class="sourceLine" id="cb1-323" title="323"></a>
<a class="sourceLine" id="cb1-324" title="324"><span class="co">; Use import to load a java module</span></a>
<a class="sourceLine" id="cb1-325" title="325">(<span class="kw">import</span> java.util.Date)</a>
<a class="sourceLine" id="cb1-326" title="326"></a>
<a class="sourceLine" id="cb1-327" title="327"><span class="co">; You can import from an ns too.</span></a>
<a class="sourceLine" id="cb1-328" title="328">(<span class="kw">ns</span> <span class="kw">test</span></a>
<a class="sourceLine" id="cb1-329" title="329">  (<span class="at">:import</span> java.util.Date</a>
<a class="sourceLine" id="cb1-330" title="330">           java.util.Calendar))</a>
<a class="sourceLine" id="cb1-331" title="331"></a>
<a class="sourceLine" id="cb1-332" title="332"><span class="co">; Use the class name with a &quot;.&quot; at the end to make a new instance</span></a>
<a class="sourceLine" id="cb1-333" title="333">(Date.) <span class="co">; &lt;a date object&gt;</span></a>
<a class="sourceLine" id="cb1-334" title="334"></a>
<a class="sourceLine" id="cb1-335" title="335"><span class="co">; Use . to call methods. Or, use the &quot;.method&quot; shortcut</span></a>
<a class="sourceLine" id="cb1-336" title="336">(. (Date.) getTime) <span class="co">; &lt;a timestamp&gt;</span></a>
<a class="sourceLine" id="cb1-337" title="337">(.getTime (Date.)) <span class="co">; exactly the same thing.</span></a>
<a class="sourceLine" id="cb1-338" title="338"></a>
<a class="sourceLine" id="cb1-339" title="339"><span class="co">; Use / to call static methods</span></a>
<a class="sourceLine" id="cb1-340" title="340">(System/currentTimeMillis) <span class="co">; &lt;a timestamp&gt; (system is always present)</span></a>
<a class="sourceLine" id="cb1-341" title="341"></a>
<a class="sourceLine" id="cb1-342" title="342"><span class="co">; Use doto to make dealing with (mutable) classes more tolerable</span></a>
<a class="sourceLine" id="cb1-343" title="343">(<span class="kw">import</span> java.util.Calendar)</a>
<a class="sourceLine" id="cb1-344" title="344">(<span class="kw">doto</span> (Calendar/getInstance)</a>
<a class="sourceLine" id="cb1-345" title="345">  (.<span class="kw">set</span> <span class="dv">2000</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-346" title="346">  .getTime) <span class="co">; =&gt; A Date. set to 2000-01-01 00:00:00</span></a>
<a class="sourceLine" id="cb1-347" title="347"></a>
<a class="sourceLine" id="cb1-348" title="348"><span class="co">; STM</span></a>
<a class="sourceLine" id="cb1-349" title="349"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-350" title="350"></a>
<a class="sourceLine" id="cb1-351" title="351"><span class="co">; Software Transactional Memory is the mechanism clojure uses to handle</span></a>
<a class="sourceLine" id="cb1-352" title="352"><span class="co">; persistent state. There are a few constructs in clojure that use this.</span></a>
<a class="sourceLine" id="cb1-353" title="353"></a>
<a class="sourceLine" id="cb1-354" title="354"><span class="co">; An atom is the simplest. Pass it an initial value</span></a>
<a class="sourceLine" id="cb1-355" title="355">(<span class="bu">def</span><span class="fu"> my-atom </span>(<span class="kw">atom</span> {}))</a>
<a class="sourceLine" id="cb1-356" title="356"></a>
<a class="sourceLine" id="cb1-357" title="357"><span class="co">; Update an atom with swap!.</span></a>
<a class="sourceLine" id="cb1-358" title="358"><span class="co">; swap! takes a function and calls it with the current value of the atom</span></a>
<a class="sourceLine" id="cb1-359" title="359"><span class="co">; as the first argument, and any trailing arguments as the second</span></a>
<a class="sourceLine" id="cb1-360" title="360">(<span class="kw">swap!</span> my-atom <span class="kw">assoc</span> <span class="at">:a</span> <span class="dv">1</span>) <span class="co">; Sets my-atom to the result of (assoc {} :a 1)</span></a>
<a class="sourceLine" id="cb1-361" title="361">(<span class="kw">swap!</span> my-atom <span class="kw">assoc</span> <span class="at">:b</span> <span class="dv">2</span>) <span class="co">; Sets my-atom to the result of (assoc {:a 1} :b 2)</span></a>
<a class="sourceLine" id="cb1-362" title="362"></a>
<a class="sourceLine" id="cb1-363" title="363"><span class="co">; Use &#39;@&#39; to dereference the atom and get the value</span></a>
<a class="sourceLine" id="cb1-364" title="364">my-atom  <span class="co">;=&gt; Atom&lt;#...&gt; (Returns the Atom object)</span></a>
<a class="sourceLine" id="cb1-365" title="365"><span class="at">@my-atom</span> <span class="co">; =&gt; {:a 1 :b 2}</span></a>
<a class="sourceLine" id="cb1-366" title="366"></a>
<a class="sourceLine" id="cb1-367" title="367"><span class="co">; Here&#39;s a simple counter using an atom</span></a>
<a class="sourceLine" id="cb1-368" title="368">(<span class="bu">def</span><span class="fu"> counter </span>(<span class="kw">atom</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-369" title="369">(<span class="bu">defn</span><span class="fu"> inc-counter </span>[]</a>
<a class="sourceLine" id="cb1-370" title="370">  (<span class="kw">swap!</span> counter <span class="kw">inc</span>))</a>
<a class="sourceLine" id="cb1-371" title="371"></a>
<a class="sourceLine" id="cb1-372" title="372">(inc-counter)</a>
<a class="sourceLine" id="cb1-373" title="373">(inc-counter)</a>
<a class="sourceLine" id="cb1-374" title="374">(inc-counter)</a>
<a class="sourceLine" id="cb1-375" title="375">(inc-counter)</a>
<a class="sourceLine" id="cb1-376" title="376">(inc-counter)</a>
<a class="sourceLine" id="cb1-377" title="377"></a>
<a class="sourceLine" id="cb1-378" title="378"><span class="at">@counter</span> <span class="co">; =&gt; 5</span></a>
<a class="sourceLine" id="cb1-379" title="379"></a>
<a class="sourceLine" id="cb1-380" title="380"><span class="co">; Other STM constructs are refs and agents.</span></a>
<a class="sourceLine" id="cb1-381" title="381"><span class="co">; Refs: http://clojure.org/refs</span></a>
<a class="sourceLine" id="cb1-382" title="382"><span class="co">; Agents: http://clojure.org/agents</span></a></code></pre></div>
<h3 id="further-reading">Further Reading</h3>
<p>This is far from exhaustive, but hopefully it’s enough to get you on your feet.</p>
<p>Clojure.org has lots of articles: <a href="http://clojure.org/">http://clojure.org/</a></p>
<p>Clojuredocs.org has documentation with examples for most core functions: <a href="http://clojuredocs.org/quickref/Clojure%20Core">http://clojuredocs.org/quickref/Clojure%20Core</a></p>
<p>4Clojure is a great way to build your clojure/FP skills: <a href="http://www.4clojure.com/">http://www.4clojure.com/</a></p>
<p>Clojure-doc.org (yes, really) has a number of getting started articles: <a href="http://clojure-doc.org/">http://clojure-doc.org/</a></p>
<p>Clojure for the Brave and True has a great introduction to Clojure and a free online version: <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/">https://www.braveclojure.com/clojure-for-the-brave-and-true/</a></p>
</body>
</html>
