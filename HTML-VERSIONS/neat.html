<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>neat.html</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>Neat is basically a smaller version of D1 with some experimental syntax and a focus on terseness without losing the basic C-like syntax.</p>
<p><a href="https://github.com/FeepingCreature/fcc/wiki">Read more here.</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// single line comments start with //</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">  multiline comments look like this</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-5" title="5">/+</a>
<a class="sourceLine" id="cb1-6" title="6">  or this</a>
<a class="sourceLine" id="cb1-7" title="7">  /+ these can be nested too, same as D +/</a>
<a class="sourceLine" id="cb1-8" title="8">+/</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">// Module name. This has to match the filename/directory.</span></a>
<a class="sourceLine" id="cb1-11" title="11">module LearnNeat;</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">// Make names from another module visible in this one.</span></a>
<a class="sourceLine" id="cb1-14" title="14">import std.file;</a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">// You can import multiple things at once.</span></a>
<a class="sourceLine" id="cb1-16" title="16">import std.math, std.util;</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">// You can even group up imports!</span></a>
<a class="sourceLine" id="cb1-18" title="18">import std.(process, socket);</a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">// Global functions!</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="dt">void</span> foo() { }</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">// Main function, same as in C.</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co">// string[] == &quot;array of strings&quot;.</span></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">// &quot;string&quot; is just an alias for char[],</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="dt">void</span> main(string[] args) {</a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="co">// Call functions with &quot;function expression&quot;.</span></a>
<a class="sourceLine" id="cb1-28" title="28">  writeln <span class="st">&quot;Hello World&quot;</span>;</a>
<a class="sourceLine" id="cb1-29" title="29">  <span class="co">// You can do it like in C too... if you really want.</span></a>
<a class="sourceLine" id="cb1-30" title="30">  writeln (<span class="st">&quot;Hello World&quot;</span>);</a>
<a class="sourceLine" id="cb1-31" title="31">  <span class="co">// Declare a variable with &quot;type identifier&quot;</span></a>
<a class="sourceLine" id="cb1-32" title="32">  string arg = (<span class="st">&quot;Hello World&quot;</span>);</a>
<a class="sourceLine" id="cb1-33" title="33">  writeln arg;</a>
<a class="sourceLine" id="cb1-34" title="34">  <span class="co">// (expression, expression) forms a tuple.</span></a>
<a class="sourceLine" id="cb1-35" title="35">  <span class="co">// There are no one-value tuples though.</span></a>
<a class="sourceLine" id="cb1-36" title="36">  <span class="co">// So you can always use () in the mathematical sense.</span></a>
<a class="sourceLine" id="cb1-37" title="37">  <span class="co">// (string) arg; &lt;- is an error</span></a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="co">    byte: 8 bit signed integer</span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="co">      char: 8 bit UTF-8 byte component.</span></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">    short: 16 bit signed integer</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">    int: 32 bit signed integer</span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">    long: 64 bit signed integer</span></a>
<a class="sourceLine" id="cb1-45" title="45"></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">    float: 32 bit floating point</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">    double: 64 bit floating point</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">    real: biggest native size floating point (80 bit on x86).</span></a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="co">    bool: true or false</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">  */</span></a>
<a class="sourceLine" id="cb1-52" title="52">  <span class="dt">int</span> a = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-53" title="53">  <span class="dt">bool</span> b = true;</a>
<a class="sourceLine" id="cb1-54" title="54">  <span class="co">// as in C, &amp;&amp; and || are short-circuit evaluating.</span></a>
<a class="sourceLine" id="cb1-55" title="55">  b = b &amp;&amp; false;</a>
<a class="sourceLine" id="cb1-56" title="56">  assert(b == false);</a>
<a class="sourceLine" id="cb1-57" title="57">  <span class="co">// &quot;&quot; are &quot;format strings&quot;. So $variable will be substituted at runtime</span></a>
<a class="sourceLine" id="cb1-58" title="58">  <span class="co">// with a formatted version of the variable.</span></a>
<a class="sourceLine" id="cb1-59" title="59">  writeln <span class="st">&quot;$a&quot;</span>;</a>
<a class="sourceLine" id="cb1-60" title="60">  <span class="co">// This will just print $a.</span></a>
<a class="sourceLine" id="cb1-61" title="61">  writeln `$a`;</a>
<a class="sourceLine" id="cb1-62" title="62">  <span class="co">// you can format expressions with $()</span></a>
<a class="sourceLine" id="cb1-63" title="63">  writeln <span class="st">&quot;$(2+2)&quot;</span>;</a>
<a class="sourceLine" id="cb1-64" title="64">  <span class="co">// Note: there is no special syntax for characters.</span></a>
<a class="sourceLine" id="cb1-65" title="65">  <span class="dt">char</span> c = <span class="st">&quot;a&quot;</span>;</a>
<a class="sourceLine" id="cb1-66" title="66">  <span class="co">// Cast values by using type: expression.</span></a>
<a class="sourceLine" id="cb1-67" title="67">  <span class="co">// There are three kinds of casts:</span></a>
<a class="sourceLine" id="cb1-68" title="68">  <span class="co">// casts that just specify conversions that would be happening automatically</span></a>
<a class="sourceLine" id="cb1-69" title="69">  <span class="co">// (implicit casts)</span></a>
<a class="sourceLine" id="cb1-70" title="70">  <span class="dt">float</span> f = <span class="dt">float</span>:<span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-71" title="71">  <span class="dt">float</span> f2 = <span class="dv">5</span>; <span class="co">// would also work</span></a>
<a class="sourceLine" id="cb1-72" title="72">  <span class="co">// casts that require throwing away information or complicated computation -</span></a>
<a class="sourceLine" id="cb1-73" title="73">  <span class="co">// those must always be done explicitly</span></a>
<a class="sourceLine" id="cb1-74" title="74">  <span class="co">// (conversion casts)</span></a>
<a class="sourceLine" id="cb1-75" title="75">  <span class="dt">int</span> i = <span class="dt">int</span>:f;</a>
<a class="sourceLine" id="cb1-76" title="76">  <span class="co">// int i = f; // would not work!</span></a>
<a class="sourceLine" id="cb1-77" title="77">  <span class="co">// and, as a last attempt, casts that just reinterpret the raw data.</span></a>
<a class="sourceLine" id="cb1-78" title="78">  <span class="co">// Those only work if the types have the same size.</span></a>
<a class="sourceLine" id="cb1-79" title="79">  string s = <span class="st">&quot;Hello World&quot;</span>;</a>
<a class="sourceLine" id="cb1-80" title="80">  <span class="co">// Arrays are (length, pointer) pairs.</span></a>
<a class="sourceLine" id="cb1-81" title="81">  <span class="co">// This is a tuple type. Tuple types are (type, type, type).</span></a>
<a class="sourceLine" id="cb1-82" title="82">  <span class="co">// The type of a tuple expression is a tuple type. (duh)</span></a>
<a class="sourceLine" id="cb1-83" title="83">  (<span class="dt">int</span>, <span class="dt">char</span>*) array = (<span class="dt">int</span>, <span class="dt">char</span>*): s;</a>
<a class="sourceLine" id="cb1-84" title="84">  <span class="co">// You can index arrays and tuples using the expression[index] syntax.</span></a>
<a class="sourceLine" id="cb1-85" title="85">  writeln <span class="st">&quot;pointer is $(array[1]) and length is $(array[0])&quot;</span>;</a>
<a class="sourceLine" id="cb1-86" title="86">  <span class="co">// You can slice them using the expression[from .. to] syntax.</span></a>
<a class="sourceLine" id="cb1-87" title="87">  <span class="co">// Slicing an array makes another array.</span></a>
<a class="sourceLine" id="cb1-88" title="88">  writeln <span class="st">&quot;$(s[0..5]) World&quot;</span>;</a>
<a class="sourceLine" id="cb1-89" title="89">  <span class="co">// Alias name = expression gives the expression a name.</span></a>
<a class="sourceLine" id="cb1-90" title="90">  <span class="co">// As opposed to a variable, aliases do not have an address</span></a>
<a class="sourceLine" id="cb1-91" title="91">  <span class="co">// and can not be assigned to. (Unless the expression is assignable)</span></a>
<a class="sourceLine" id="cb1-92" title="92">  alias range = <span class="dv">0</span> .. <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-93" title="93">  writeln <span class="st">&quot;$(s[range]) World&quot;</span>;</a>
<a class="sourceLine" id="cb1-94" title="94">  <span class="co">// You can iterate over ranges.</span></a>
<a class="sourceLine" id="cb1-95" title="95">  <span class="cf">for</span> <span class="dt">int</span> i &lt;- range {</a>
<a class="sourceLine" id="cb1-96" title="96">    write <span class="st">&quot;$(s[i])&quot;</span>;</a>
<a class="sourceLine" id="cb1-97" title="97">  }</a>
<a class="sourceLine" id="cb1-98" title="98">  writeln <span class="st">&quot; World&quot;</span>;</a>
<a class="sourceLine" id="cb1-99" title="99">  <span class="co">// Note that if &quot;range&quot; had been a variable, it would be &#39;empty&#39; now!</span></a>
<a class="sourceLine" id="cb1-100" title="100">  <span class="co">// Range variables can only be iterated once.</span></a>
<a class="sourceLine" id="cb1-101" title="101">  <span class="co">// The syntax for iteration is &quot;expression &lt;- iterable&quot;.</span></a>
<a class="sourceLine" id="cb1-102" title="102">  <span class="co">// Lots of things are iterable.</span></a>
<a class="sourceLine" id="cb1-103" title="103">  <span class="cf">for</span> <span class="dt">char</span> c &lt;- <span class="st">&quot;Hello&quot;</span> { write <span class="st">&quot;$c&quot;</span>; }</a>
<a class="sourceLine" id="cb1-104" title="104">  writeln <span class="st">&quot; World&quot;</span>;</a>
<a class="sourceLine" id="cb1-105" title="105">  <span class="co">// For loops are &quot;for test statement&quot;;</span></a>
<a class="sourceLine" id="cb1-106" title="106">  alias test = <span class="dt">char</span> d &lt;- <span class="st">&quot;Hello&quot;</span>;</a>
<a class="sourceLine" id="cb1-107" title="107">  <span class="cf">for</span> test write <span class="st">&quot;$d&quot;</span>;</a>
<a class="sourceLine" id="cb1-108" title="108">  writeln <span class="st">&quot; World</span><span class="sc">\t\x05</span><span class="st">&quot;</span>; <span class="co">// note: escapes work</span></a>
<a class="sourceLine" id="cb1-109" title="109">  <span class="co">// Pointers: function the same as in C, btw. The usual.</span></a>
<a class="sourceLine" id="cb1-110" title="110">  <span class="co">// Do note: the pointer star sticks with the TYPE, not the VARIABLE!</span></a>
<a class="sourceLine" id="cb1-111" title="111">  string* p;</a>
<a class="sourceLine" id="cb1-112" title="112">  assert(p == null); <span class="co">// default initializer</span></a>
<a class="sourceLine" id="cb1-113" title="113">  p = &amp;s;</a>
<a class="sourceLine" id="cb1-114" title="114">  writeln <span class="st">&quot;$(*p)&quot;</span>;</a>
<a class="sourceLine" id="cb1-115" title="115">  <span class="co">// Math operators are (almost) standard.</span></a>
<a class="sourceLine" id="cb1-116" title="116">  <span class="dt">int</span> x = <span class="dv">2</span> + <span class="dv">3</span> * <span class="dv">4</span> &lt;&lt; <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-117" title="117">  <span class="co">// Note: XOR is &quot;xor&quot;. ^ is reserved for exponentiation (once I implement that).</span></a>
<a class="sourceLine" id="cb1-118" title="118">  <span class="dt">int</span> y = <span class="dv">3</span> xor <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-119" title="119">  <span class="dt">int</span> z = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-120" title="120">  assert(z++ == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-121" title="121">  assert(++z == <span class="dv">7</span>);</a>
<a class="sourceLine" id="cb1-122" title="122">  writeln <span class="st">&quot;x $x y $y z $z&quot;</span>;</a>
<a class="sourceLine" id="cb1-123" title="123">  <span class="co">// As in D, ~ concatenates.</span></a>
<a class="sourceLine" id="cb1-124" title="124">  string hewo = <span class="st">&quot;Hello &quot;</span> ~ <span class="st">&quot;World&quot;</span>;</a>
<a class="sourceLine" id="cb1-125" title="125">  <span class="co">// == tests for equality, &quot;is&quot; tests for identity.</span></a>
<a class="sourceLine" id="cb1-126" title="126">  assert  (hewo == s);</a>
<a class="sourceLine" id="cb1-127" title="127">  assert !(hewo is s);</a>
<a class="sourceLine" id="cb1-128" title="128">  <span class="co">// same as</span></a>
<a class="sourceLine" id="cb1-129" title="129">  assert  (hewo !is s);</a>
<a class="sourceLine" id="cb1-130" title="130"></a>
<a class="sourceLine" id="cb1-131" title="131">  <span class="co">// Allocate arrays using &quot;new array length&quot;</span></a>
<a class="sourceLine" id="cb1-132" title="132">  <span class="dt">int</span>[] integers = new <span class="dt">int</span>[] <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb1-133" title="133">  assert(integers.length == <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb1-134" title="134">  assert(integers[<span class="dv">0</span>] == <span class="dv">0</span>); <span class="co">// zero is default initializer</span></a>
<a class="sourceLine" id="cb1-135" title="135">  integers = integers ~ <span class="dv">5</span>; <span class="co">// This allocates a new array!</span></a>
<a class="sourceLine" id="cb1-136" title="136">  assert(integers.length == <span class="dv">11</span>);</a>
<a class="sourceLine" id="cb1-137" title="137"></a>
<a class="sourceLine" id="cb1-138" title="138">  <span class="co">// This is an appender array.</span></a>
<a class="sourceLine" id="cb1-139" title="139">  <span class="co">// Instead of (length, pointer), it tracks (capacity, length, pointer).</span></a>
<a class="sourceLine" id="cb1-140" title="140">  <span class="co">// When you append to it, it will use the free capacity if it can.</span></a>
<a class="sourceLine" id="cb1-141" title="141">  <span class="co">// If it runs out of space, it reallocates - but it will free the old array automatically.</span></a>
<a class="sourceLine" id="cb1-142" title="142">  <span class="co">// This makes it convenient for building arrays.</span></a>
<a class="sourceLine" id="cb1-143" title="143">  <span class="dt">int</span>[<span class="dt">auto</span>~] appender;</a>
<a class="sourceLine" id="cb1-144" title="144">  appender ~= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-145" title="145">  appender ~= <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb1-146" title="146">  appender.free(); <span class="co">// same as {mem.free(appender.ptr); appender = null;}</span></a>
<a class="sourceLine" id="cb1-147" title="147"></a>
<a class="sourceLine" id="cb1-148" title="148">  <span class="co">// Scope variables are automatically freed at the end of the current scope.</span></a>
<a class="sourceLine" id="cb1-149" title="149">  scope <span class="dt">int</span>[<span class="dt">auto</span>~] someOtherAppender;</a>
<a class="sourceLine" id="cb1-150" title="150">  <span class="co">// This is the same as:</span></a>
<a class="sourceLine" id="cb1-151" title="151">  <span class="dt">int</span>[<span class="dt">auto</span>~] someOtherAppender2;</a>
<a class="sourceLine" id="cb1-152" title="152">  onExit { someOtherAppender2.free; }</a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154">  <span class="co">// You can do a C for loop too</span></a>
<a class="sourceLine" id="cb1-155" title="155">  <span class="co">// - but why would you want to?</span></a>
<a class="sourceLine" id="cb1-156" title="156">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; ++i) { }</a>
<a class="sourceLine" id="cb1-157" title="157">  <span class="co">// Otherwise, for and while are the same.</span></a>
<a class="sourceLine" id="cb1-158" title="158">  <span class="cf">while</span> <span class="dt">int</span> i &lt;- <span class="fl">0.</span><span class="er">.4</span> {</a>
<a class="sourceLine" id="cb1-159" title="159">    assert(i == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-160" title="160">    <span class="cf">break</span>; <span class="co">// continue works too</span></a>
<a class="sourceLine" id="cb1-161" title="161">  } then assert(false); <span class="co">// if we hadn&#39;t break&#39;d, this would run at the end</span></a>
<a class="sourceLine" id="cb1-162" title="162">  <span class="co">// This is the height of loopdom - the produce-test-consume loop.</span></a>
<a class="sourceLine" id="cb1-163" title="163">  <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb1-164" title="164">    <span class="dt">int</span> i = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-165" title="165">  } <span class="cf">while</span> (i == <span class="dv">5</span>) {</a>
<a class="sourceLine" id="cb1-166" title="166">    assert(i == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-167" title="167">    <span class="cf">break</span>; <span class="co">// otherwise we&#39;d go back up to do {</span></a>
<a class="sourceLine" id="cb1-168" title="168">  }</a>
<a class="sourceLine" id="cb1-169" title="169"></a>
<a class="sourceLine" id="cb1-170" title="170">  <span class="co">// This is a nested function.</span></a>
<a class="sourceLine" id="cb1-171" title="171">  <span class="co">// Nested functions can access the surrounding function.</span></a>
<a class="sourceLine" id="cb1-172" title="172">  string returnS() { <span class="cf">return</span> s; }</a>
<a class="sourceLine" id="cb1-173" title="173">  writeln returnS();</a>
<a class="sourceLine" id="cb1-174" title="174"></a>
<a class="sourceLine" id="cb1-175" title="175">  <span class="co">// Take the address of a function using &amp;</span></a>
<a class="sourceLine" id="cb1-176" title="176">  <span class="co">// The type of a global function is ReturnType function(ParameterTypeTuple).</span></a>
<a class="sourceLine" id="cb1-177" title="177">  <span class="dt">void</span> function() foop = &amp;foo;</a>
<a class="sourceLine" id="cb1-178" title="178"></a>
<a class="sourceLine" id="cb1-179" title="179">  <span class="co">// Similarly, the type of a nested function is ReturnType delegate(ParameterTypeTuple).</span></a>
<a class="sourceLine" id="cb1-180" title="180">  string delegate() returnSp = &amp;returnS;</a>
<a class="sourceLine" id="cb1-181" title="181">  writeln returnSp();</a>
<a class="sourceLine" id="cb1-182" title="182">  <span class="co">// Class member functions and struct member functions also fit into delegate variables.</span></a>
<a class="sourceLine" id="cb1-183" title="183">  <span class="co">// In general, delegates are functions that carry an additional context pointer.</span></a>
<a class="sourceLine" id="cb1-184" title="184">  <span class="co">// (&quot;fat pointers&quot; in C)</span></a>
<a class="sourceLine" id="cb1-185" title="185"></a>
<a class="sourceLine" id="cb1-186" title="186">  <span class="co">// Allocate a &quot;snapshot&quot; with &quot;new delegate&quot;.</span></a>
<a class="sourceLine" id="cb1-187" title="187">  <span class="co">// Snapshots are not closures! I used to call them closures too,</span></a>
<a class="sourceLine" id="cb1-188" title="188">  <span class="co">// but then my Haskell-using friends yelled at me so I had to stop.</span></a>
<a class="sourceLine" id="cb1-189" title="189">  <span class="co">// The difference is that snapshots &quot;capture&quot; their surrounding context</span></a>
<a class="sourceLine" id="cb1-190" title="190">  <span class="co">// when &quot;new&quot; is used.</span></a>
<a class="sourceLine" id="cb1-191" title="191">  <span class="co">// This allows things like this</span></a>
<a class="sourceLine" id="cb1-192" title="192">  <span class="dt">int</span> delegate(<span class="dt">int</span>) add(<span class="dt">int</span> a) {</a>
<a class="sourceLine" id="cb1-193" title="193">    <span class="dt">int</span> add_a(<span class="dt">int</span> b) { <span class="cf">return</span> a + b; }</a>
<a class="sourceLine" id="cb1-194" title="194">    <span class="co">// This does not work - the context of add_a becomes invalid</span></a>
<a class="sourceLine" id="cb1-195" title="195">    <span class="co">// when add returns.</span></a>
<a class="sourceLine" id="cb1-196" title="196">    <span class="co">// return &amp;add_a;</span></a>
<a class="sourceLine" id="cb1-197" title="197">    <span class="co">// Instead:</span></a>
<a class="sourceLine" id="cb1-198" title="198">    <span class="cf">return</span> new &amp;add_a;</a>
<a class="sourceLine" id="cb1-199" title="199">  }</a>
<a class="sourceLine" id="cb1-200" title="200">  <span class="dt">int</span> delegate(<span class="dt">int</span>) dg = add <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-201" title="201">  assert (dg(<span class="dv">3</span>) == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-202" title="202">  <span class="co">// or</span></a>
<a class="sourceLine" id="cb1-203" title="203">  assert (((add <span class="dv">2</span>) <span class="dv">3</span>) == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-204" title="204">  <span class="co">// or</span></a>
<a class="sourceLine" id="cb1-205" title="205">  assert (add <span class="dv">2</span> <span class="dv">3</span> == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-206" title="206">  <span class="co">// add can also be written as</span></a>
<a class="sourceLine" id="cb1-207" title="207">  <span class="dt">int</span> delegate(<span class="dt">int</span>) add2(<span class="dt">int</span> a) {</a>
<a class="sourceLine" id="cb1-208" title="208">    <span class="co">// this is an implicit, nameless nested function.</span></a>
<a class="sourceLine" id="cb1-209" title="209">    <span class="cf">return</span> new λ(<span class="dt">int</span> b) { <span class="cf">return</span> a + b; }</a>
<a class="sourceLine" id="cb1-210" title="210">  }</a>
<a class="sourceLine" id="cb1-211" title="211">  <span class="co">// or even</span></a>
<a class="sourceLine" id="cb1-212" title="212">  <span class="dt">auto</span> add3(<span class="dt">int</span> a) { <span class="cf">return</span> new λ(<span class="dt">int</span> b) -&gt; a + b; }</a>
<a class="sourceLine" id="cb1-213" title="213">  <span class="co">// hahahaaa</span></a>
<a class="sourceLine" id="cb1-214" title="214">  <span class="dt">auto</span> add4 = λ(<span class="dt">int</span> a) -&gt; new λ(<span class="dt">int</span> b) -&gt; a + b;</a>
<a class="sourceLine" id="cb1-215" title="215">  assert(add4 <span class="dv">2</span> <span class="dv">3</span> == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-216" title="216">  <span class="co">// If your keyboard doesn&#39;t have a λ (you poor sod)</span></a>
<a class="sourceLine" id="cb1-217" title="217">  <span class="co">// you can use \ too.</span></a>
<a class="sourceLine" id="cb1-218" title="218">  <span class="dt">auto</span> add5 = \(<span class="dt">int</span> a) -&gt; new \(<span class="dt">int</span> b) -&gt; a + b;</a>
<a class="sourceLine" id="cb1-219" title="219">  <span class="co">// Note!</span></a>
<a class="sourceLine" id="cb1-220" title="220">  <span class="dt">auto</span> nestfun = λ() { } <span class="co">// There is NO semicolon needed here!</span></a>
<a class="sourceLine" id="cb1-221" title="221">  <span class="co">// &quot;}&quot; can always substitute for &quot;};&quot;.</span></a>
<a class="sourceLine" id="cb1-222" title="222">  <span class="co">// This provides syntactic consistency with built-in statements.</span></a>
<a class="sourceLine" id="cb1-223" title="223"></a>
<a class="sourceLine" id="cb1-224" title="224"></a>
<a class="sourceLine" id="cb1-225" title="225">  <span class="co">// This is a class.</span></a>
<a class="sourceLine" id="cb1-226" title="226">  <span class="co">// Note: almost all elements of Neat can be used on the module level</span></a>
<a class="sourceLine" id="cb1-227" title="227">  <span class="co">//       or just as well inside a function.</span></a>
<a class="sourceLine" id="cb1-228" title="228">  class C {</a>
<a class="sourceLine" id="cb1-229" title="229">    <span class="dt">int</span> a;</a>
<a class="sourceLine" id="cb1-230" title="230">    <span class="dt">void</span> writeA() { writeln <span class="st">&quot;$a&quot;</span>; }</a>
<a class="sourceLine" id="cb1-231" title="231">    <span class="co">// It&#39;s a nested class - it exists in the context of main().</span></a>
<a class="sourceLine" id="cb1-232" title="232">    <span class="co">// so if you leave main(), any instances of C become invalid.</span></a>
<a class="sourceLine" id="cb1-233" title="233">    <span class="dt">void</span> writeS() { writeln <span class="st">&quot;$s&quot;</span>; }</a>
<a class="sourceLine" id="cb1-234" title="234">  }</a>
<a class="sourceLine" id="cb1-235" title="235">  C cc = new C;</a>
<a class="sourceLine" id="cb1-236" title="236">  <span class="co">// cc is a *reference* to C. Classes are always references.</span></a>
<a class="sourceLine" id="cb1-237" title="237">  cc.a = <span class="dv">5</span>; <span class="co">// Always used for property access.</span></a>
<a class="sourceLine" id="cb1-238" title="238">  <span class="dt">auto</span> ccp = &amp;cc;</a>
<a class="sourceLine" id="cb1-239" title="239">  (*ccp).a = <span class="dv">6</span>;</a>
<a class="sourceLine" id="cb1-240" title="240">  <span class="co">// or just</span></a>
<a class="sourceLine" id="cb1-241" title="241">  ccp.a = <span class="dv">7</span>;</a>
<a class="sourceLine" id="cb1-242" title="242">  cc.writeA();</a>
<a class="sourceLine" id="cb1-243" title="243">  cc.writeS(); <span class="co">// to prove I&#39;m not making things up</span></a>
<a class="sourceLine" id="cb1-244" title="244">  <span class="co">// Interfaces work same as in D, basically. Or Java.</span></a>
<a class="sourceLine" id="cb1-245" title="245">  interface E { <span class="dt">void</span> doE(); }</a>
<a class="sourceLine" id="cb1-246" title="246">  <span class="co">// Inheritance works same as in D, basically. Or Java.</span></a>
<a class="sourceLine" id="cb1-247" title="247">  class D : C, E {</a>
<a class="sourceLine" id="cb1-248" title="248">    override <span class="dt">void</span> writeA() { writeln <span class="st">&quot;hahahahaha no&quot;</span>; }</a>
<a class="sourceLine" id="cb1-249" title="249">    override <span class="dt">void</span> doE() { writeln <span class="st">&quot;eeeee&quot;</span>; }</a>
<a class="sourceLine" id="cb1-250" title="250">    <span class="co">// all classes inherit from Object. (toString is defined in Object)</span></a>
<a class="sourceLine" id="cb1-251" title="251">    override string toString() { <span class="cf">return</span> <span class="st">&quot;I am a D&quot;</span>; }</a>
<a class="sourceLine" id="cb1-252" title="252">  }</a>
<a class="sourceLine" id="cb1-253" title="253">  C cd = new D;</a>
<a class="sourceLine" id="cb1-254" title="254">  <span class="co">// all methods are always virtual.</span></a>
<a class="sourceLine" id="cb1-255" title="255">  cd.writeA();</a>
<a class="sourceLine" id="cb1-256" title="256">  E e = E:cd; <span class="co">// dynamic class cast!</span></a>
<a class="sourceLine" id="cb1-257" title="257">  e.doE();</a>
<a class="sourceLine" id="cb1-258" title="258">  writeln <span class="st">&quot;$e&quot;</span>; <span class="co">// all interfaces convert to Object implicitly.</span></a>
<a class="sourceLine" id="cb1-259" title="259"></a>
<a class="sourceLine" id="cb1-260" title="260">  <span class="co">// Templates!</span></a>
<a class="sourceLine" id="cb1-261" title="261">  <span class="co">// Templates are parameterized namespaces, taking a type as a parameter.</span></a>
<a class="sourceLine" id="cb1-262" title="262">  template Templ(T) {</a>
<a class="sourceLine" id="cb1-263" title="263">    alias hi = <span class="dv">5</span>, hii = <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb1-264" title="264">    <span class="co">// Templates always have to include something with the same name as the template</span></a>
<a class="sourceLine" id="cb1-265" title="265">    <span class="co">// - this will become the template&#39;s _value_.</span></a>
<a class="sourceLine" id="cb1-266" title="266">    <span class="co">// Static ifs are evaluated statically, at compile-time.</span></a>
<a class="sourceLine" id="cb1-267" title="267">    <span class="co">// Because of this, the test has to be a constant expression,</span></a>
<a class="sourceLine" id="cb1-268" title="268">    <span class="co">// or something that can be optimized to a constant.</span></a>
<a class="sourceLine" id="cb1-269" title="269">    <span class="dt">static</span> <span class="cf">if</span> (types-equal (T, <span class="dt">int</span>)) {</a>
<a class="sourceLine" id="cb1-270" title="270">      alias Templ = hi;</a>
<a class="sourceLine" id="cb1-271" title="271">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-272" title="272">      alias Templ = hii;</a>
<a class="sourceLine" id="cb1-273" title="273">    }</a>
<a class="sourceLine" id="cb1-274" title="274">  }</a>
<a class="sourceLine" id="cb1-275" title="275">  assert(Templ!<span class="dt">int</span> == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb1-276" title="276">  assert(Templ!<span class="dt">float</span> == <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb1-277" title="277">}</a></code></pre></div>
<h2 id="topics-not-covered">Topics Not Covered</h2>
<ul>
<li>Extended iterator types and expressions</li>
<li>Standard library</li>
<li>Conditions (error handling)</li>
<li>Macros</li>
</ul>
</body>
</html>
