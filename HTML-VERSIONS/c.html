<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>c.html</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>Ah, C. Still <strong>the</strong> language of modern high-performance computing.</p>
<p>C is the lowest-level language most programmers will ever use, but it more than makes up for it with raw speed. Just be aware of its manual memory management and C will take you as far as you need to go.</p>
<blockquote>
<p><strong>About compiler flags</strong></p>
<p>By default, gcc and clang are pretty quiet about compilation warnings and errors, which can be very useful information. Explicitly using stricter compiler flags is recommended. Here are some recommended defaults:</p>
<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>
<p>For information on what these flags do as well as other flags, consult the man page for your C compiler (e.g.Â <code>man 1 gcc</code>) or just search online.</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// Single-line comments start with // - only available in C99 and later.</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">Multi-line comments look like this. They work in C89 as well.</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">Multi-line comments don&#39;t nest /* Be careful */</span>  <span class="co">// comment ends on this line...</span></a>
<a class="sourceLine" id="cb1-9" title="9">*/ <span class="co">// ...not this one!</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">// Constants: #define &lt;keyword&gt;</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">// Constants are written in all-caps out of convention, not requirement</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="pp">#define DAYS_IN_YEAR 365</span></a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">// Enumeration constants are also ways to declare constants.</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">// All statements must end with a semicolon</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">enum</span> days {SUN = <span class="dv">1</span>, MON, TUE, WED, THU, FRI, SAT};</a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">// MON gets 2 automatically, TUE gets 3, etc.</span></a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">// Import headers with #include</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">// (File names between &lt;angle brackets&gt; are headers from the C standard library.)</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">// For your own headers, use double quotes instead of angle brackets:</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">//#include &quot;my_header.h&quot;</span></a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">// Declare function signatures in advance in a .h file, or at the top of</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">// your .c file.</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="dt">void</span> function_1();</a>
<a class="sourceLine" id="cb1-32" title="32"><span class="dt">int</span> function_2(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb1-33" title="33"></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">// Must declare a &#39;function prototype&#39; before main() when functions occur after</span></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="co">// your main() function.</span></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="dt">int</span> add_two_ints(<span class="dt">int</span> x1, <span class="dt">int</span> x2); <span class="co">// function prototype</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">// although `int add_two_ints(int, int);` is also valid (no need to name the args),</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">// it is recommended to name arguments in the prototype as well for easier inspection</span></a>
<a class="sourceLine" id="cb1-39" title="39"></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="co">// Your program&#39;s entry point is a function called</span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="co">// main with an integer return type.</span></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="dt">int</span> main(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb1-43" title="43">  <span class="co">// your program</span></a>
<a class="sourceLine" id="cb1-44" title="44">}</a>
<a class="sourceLine" id="cb1-45" title="45"></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">// The command line arguments used to run your program are also passed to main</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">// argc being the number of arguments - your program&#39;s name counts as 1</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">// argv is an array of character arrays - containing the arguments themselves</span></a>
<a class="sourceLine" id="cb1-49" title="49"><span class="co">// argv[0] = name of your program, argv[1] = first argument, etc.</span></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="dt">int</span> main (<span class="dt">int</span> argc, <span class="dt">char</span>** argv)</a>
<a class="sourceLine" id="cb1-51" title="51">{</a>
<a class="sourceLine" id="cb1-52" title="52">  <span class="co">// print output using printf, for &quot;print formatted&quot;</span></a>
<a class="sourceLine" id="cb1-53" title="53">  <span class="co">// %d is an integer, \n is a newline</span></a>
<a class="sourceLine" id="cb1-54" title="54">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">0</span>); <span class="co">// =&gt; Prints 0</span></a>
<a class="sourceLine" id="cb1-55" title="55"></a>
<a class="sourceLine" id="cb1-56" title="56">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-57" title="57">  <span class="co">// Types</span></a>
<a class="sourceLine" id="cb1-58" title="58">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60">  <span class="co">// Compilers that are not C99-compliant require that variables MUST be</span></a>
<a class="sourceLine" id="cb1-61" title="61">  <span class="co">// declared at the top of the current block scope.</span></a>
<a class="sourceLine" id="cb1-62" title="62">  <span class="co">// Compilers that ARE C99-compliant allow declarations near the point where</span></a>
<a class="sourceLine" id="cb1-63" title="63">  <span class="co">// the value is used.</span></a>
<a class="sourceLine" id="cb1-64" title="64">  <span class="co">// For the sake of the tutorial, variables are declared dynamically under</span></a>
<a class="sourceLine" id="cb1-65" title="65">  <span class="co">// C99-compliant standards.</span></a>
<a class="sourceLine" id="cb1-66" title="66"></a>
<a class="sourceLine" id="cb1-67" title="67">  <span class="co">// ints are usually 4 bytes</span></a>
<a class="sourceLine" id="cb1-68" title="68">  <span class="dt">int</span> x_int = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-69" title="69"></a>
<a class="sourceLine" id="cb1-70" title="70">  <span class="co">// shorts are usually 2 bytes</span></a>
<a class="sourceLine" id="cb1-71" title="71">  <span class="dt">short</span> x_short = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-72" title="72"></a>
<a class="sourceLine" id="cb1-73" title="73">  <span class="co">// chars are guaranteed to be 1 byte</span></a>
<a class="sourceLine" id="cb1-74" title="74">  <span class="dt">char</span> x_char = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-75" title="75">  <span class="dt">char</span> y_char = <span class="ch">&#39;y&#39;</span>; <span class="co">// Char literals are quoted with &#39;&#39;</span></a>
<a class="sourceLine" id="cb1-76" title="76"></a>
<a class="sourceLine" id="cb1-77" title="77">  <span class="co">// longs are often 4 to 8 bytes; long longs are guaranteed to be at least</span></a>
<a class="sourceLine" id="cb1-78" title="78">  <span class="co">// 8 bytes</span></a>
<a class="sourceLine" id="cb1-79" title="79">  <span class="dt">long</span> x_long = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-80" title="80">  <span class="dt">long</span> <span class="dt">long</span> x_long_long = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-81" title="81"></a>
<a class="sourceLine" id="cb1-82" title="82">  <span class="co">// floats are usually 32-bit floating point numbers</span></a>
<a class="sourceLine" id="cb1-83" title="83">  <span class="dt">float</span> x_float = <span class="fl">0.0</span><span class="bu">f</span>; <span class="co">// &#39;f&#39; suffix here denotes floating point literal</span></a>
<a class="sourceLine" id="cb1-84" title="84"></a>
<a class="sourceLine" id="cb1-85" title="85">  <span class="co">// doubles are usually 64-bit floating-point numbers</span></a>
<a class="sourceLine" id="cb1-86" title="86">  <span class="dt">double</span> x_double = <span class="fl">0.0</span>; <span class="co">// real numbers without any suffix are doubles</span></a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88">  <span class="co">// integer types may be unsigned (greater than or equal to zero)</span></a>
<a class="sourceLine" id="cb1-89" title="89">  <span class="dt">unsigned</span> <span class="dt">short</span> ux_short;</a>
<a class="sourceLine" id="cb1-90" title="90">  <span class="dt">unsigned</span> <span class="dt">int</span> ux_int;</a>
<a class="sourceLine" id="cb1-91" title="91">  <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ux_long_long;</a>
<a class="sourceLine" id="cb1-92" title="92"></a>
<a class="sourceLine" id="cb1-93" title="93">  <span class="co">// chars inside single quotes are integers in machine&#39;s character set.</span></a>
<a class="sourceLine" id="cb1-94" title="94">  <span class="ch">&#39;0&#39;</span>; <span class="co">// =&gt; 48 in the ASCII character set.</span></a>
<a class="sourceLine" id="cb1-95" title="95">  <span class="ch">&#39;A&#39;</span>; <span class="co">// =&gt; 65 in the ASCII character set.</span></a>
<a class="sourceLine" id="cb1-96" title="96"></a>
<a class="sourceLine" id="cb1-97" title="97">  <span class="co">// sizeof(T) gives you the size of a variable with type T in bytes</span></a>
<a class="sourceLine" id="cb1-98" title="98">  <span class="co">// sizeof(obj) yields the size of the expression (variable, literal, etc.).</span></a>
<a class="sourceLine" id="cb1-99" title="99">  printf(<span class="st">&quot;%zu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>)); <span class="co">// =&gt; 4 (on most machines with 4-byte words)</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101">  <span class="co">// If the argument of the `sizeof` operator is an expression, then its argument</span></a>
<a class="sourceLine" id="cb1-102" title="102">  <span class="co">// is not evaluated (except VLAs (see below)).</span></a>
<a class="sourceLine" id="cb1-103" title="103">  <span class="co">// The value it yields in this case is a compile-time constant.</span></a>
<a class="sourceLine" id="cb1-104" title="104">  <span class="dt">int</span> a = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1-105" title="105">  <span class="co">// size_t is an unsigned integer type of at least 2 bytes used to represent</span></a>
<a class="sourceLine" id="cb1-106" title="106">  <span class="co">// the size of an object.</span></a>
<a class="sourceLine" id="cb1-107" title="107">  <span class="dt">size_t</span> size = <span class="kw">sizeof</span>(a++); <span class="co">// a++ is not evaluated</span></a>
<a class="sourceLine" id="cb1-108" title="108">  printf(<span class="st">&quot;sizeof(a++) = %zu where a = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, size, a);</a>
<a class="sourceLine" id="cb1-109" title="109">  <span class="co">// prints &quot;sizeof(a++) = 4 where a = 1&quot; (on a 32-bit architecture)</span></a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111">  <span class="co">// Arrays must be initialized with a concrete size.</span></a>
<a class="sourceLine" id="cb1-112" title="112">  <span class="dt">char</span> my_char_array[<span class="dv">20</span>]; <span class="co">// This array occupies 1 * 20 = 20 bytes</span></a>
<a class="sourceLine" id="cb1-113" title="113">  <span class="dt">int</span> my_int_array[<span class="dv">20</span>]; <span class="co">// This array occupies 4 * 20 = 80 bytes</span></a>
<a class="sourceLine" id="cb1-114" title="114">  <span class="co">// (assuming 4-byte words)</span></a>
<a class="sourceLine" id="cb1-115" title="115"></a>
<a class="sourceLine" id="cb1-116" title="116">  <span class="co">// You can initialize an array to 0 thusly:</span></a>
<a class="sourceLine" id="cb1-117" title="117">  <span class="dt">char</span> my_array[<span class="dv">20</span>] = {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb1-118" title="118">  <span class="co">// where the &quot;{0}&quot; part is called an &quot;array initializer&quot;.</span></a>
<a class="sourceLine" id="cb1-119" title="119">  <span class="co">// </span><span class="al">NOTE</span><span class="co"> that you get away without explicitly declaring the size of the array,</span></a>
<a class="sourceLine" id="cb1-120" title="120">  <span class="co">// IF you initialize the array on the same line. So, the following declaration</span></a>
<a class="sourceLine" id="cb1-121" title="121">  <span class="co">// is equivalent:</span></a>
<a class="sourceLine" id="cb1-122" title="122">  <span class="dt">char</span> my_array[] = {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb1-123" title="123">  <span class="co">// BUT, then you have to evaluate the size of the array at run-time, like this:</span></a>
<a class="sourceLine" id="cb1-124" title="124">  <span class="dt">size_t</span> my_array_size = <span class="kw">sizeof</span>(my_array) / <span class="kw">sizeof</span>(my_array[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb1-125" title="125">  <span class="co">// </span><span class="al">WARNING</span><span class="co"> If you adopt this approach, you should evaluate the size *before*</span></a>
<a class="sourceLine" id="cb1-126" title="126">  <span class="co">// you begin passing the array to function (see later discussion), because</span></a>
<a class="sourceLine" id="cb1-127" title="127">  <span class="co">// arrays get &quot;downgraded&quot; to raw pointers when they are passed to functions</span></a>
<a class="sourceLine" id="cb1-128" title="128">  <span class="co">// (so the statement above will produce the wrong result inside the function).</span></a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130">  <span class="co">// Indexing an array is like other languages -- or,</span></a>
<a class="sourceLine" id="cb1-131" title="131">  <span class="co">// rather, other languages are like C</span></a>
<a class="sourceLine" id="cb1-132" title="132">  my_array[<span class="dv">0</span>]; <span class="co">// =&gt; 0</span></a>
<a class="sourceLine" id="cb1-133" title="133"></a>
<a class="sourceLine" id="cb1-134" title="134">  <span class="co">// Arrays are mutable; it&#39;s just memory!</span></a>
<a class="sourceLine" id="cb1-135" title="135">  my_array[<span class="dv">1</span>] = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-136" title="136">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, my_array[<span class="dv">1</span>]); <span class="co">// =&gt; 2</span></a>
<a class="sourceLine" id="cb1-137" title="137"></a>
<a class="sourceLine" id="cb1-138" title="138">  <span class="co">// In C99 (and as an optional feature in C11), variable-length arrays (VLAs)</span></a>
<a class="sourceLine" id="cb1-139" title="139">  <span class="co">// can be declared as well. The size of such an array need not be a compile</span></a>
<a class="sourceLine" id="cb1-140" title="140">  <span class="co">// time constant:</span></a>
<a class="sourceLine" id="cb1-141" title="141">  printf(<span class="st">&quot;Enter the array size: &quot;</span>); <span class="co">// ask the user for an array size</span></a>
<a class="sourceLine" id="cb1-142" title="142">  <span class="dt">int</span> array_size;</a>
<a class="sourceLine" id="cb1-143" title="143">  fscanf(stdin, <span class="st">&quot;%d&quot;</span>, &amp;array_size);</a>
<a class="sourceLine" id="cb1-144" title="144">  <span class="dt">int</span> var_length_array[array_size]; <span class="co">// declare the VLA</span></a>
<a class="sourceLine" id="cb1-145" title="145">  printf(<span class="st">&quot;sizeof array = %zu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span> var_length_array);</a>
<a class="sourceLine" id="cb1-146" title="146"></a>
<a class="sourceLine" id="cb1-147" title="147">  <span class="co">// Example:</span></a>
<a class="sourceLine" id="cb1-148" title="148">  <span class="co">// &gt; Enter the array size: 10</span></a>
<a class="sourceLine" id="cb1-149" title="149">  <span class="co">// &gt; sizeof array = 40</span></a>
<a class="sourceLine" id="cb1-150" title="150"></a>
<a class="sourceLine" id="cb1-151" title="151">  <span class="co">// Strings are just arrays of chars terminated by a NULL (0x00) byte,</span></a>
<a class="sourceLine" id="cb1-152" title="152">  <span class="co">// represented in strings as the special character &#39;\0&#39;.</span></a>
<a class="sourceLine" id="cb1-153" title="153">  <span class="co">// (We don&#39;t have to include the NULL byte in string literals; the compiler</span></a>
<a class="sourceLine" id="cb1-154" title="154">  <span class="co">//  inserts it at the end of the array for us.)</span></a>
<a class="sourceLine" id="cb1-155" title="155">  <span class="dt">char</span> a_string[<span class="dv">20</span>] = <span class="st">&quot;This is a string&quot;</span>;</a>
<a class="sourceLine" id="cb1-156" title="156">  printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, a_string); <span class="co">// %s formats a string</span></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, a_string[<span class="dv">16</span>]); <span class="co">// =&gt; 0</span></a>
<a class="sourceLine" id="cb1-159" title="159">  <span class="co">// i.e., byte #17 is 0 (as are 18, 19, and 20)</span></a>
<a class="sourceLine" id="cb1-160" title="160"></a>
<a class="sourceLine" id="cb1-161" title="161">  <span class="co">// If we have characters between single quotes, that&#39;s a character literal.</span></a>
<a class="sourceLine" id="cb1-162" title="162">  <span class="co">// It&#39;s of type `int`, and *not* `char` (for historical reasons).</span></a>
<a class="sourceLine" id="cb1-163" title="163">  <span class="dt">int</span> cha = <span class="ch">&#39;a&#39;</span>; <span class="co">// fine</span></a>
<a class="sourceLine" id="cb1-164" title="164">  <span class="dt">char</span> chb = <span class="ch">&#39;a&#39;</span>; <span class="co">// fine too (implicit conversion from int to char)</span></a>
<a class="sourceLine" id="cb1-165" title="165"></a>
<a class="sourceLine" id="cb1-166" title="166">  <span class="co">// Multi-dimensional arrays:</span></a>
<a class="sourceLine" id="cb1-167" title="167">  <span class="dt">int</span> multi_array[<span class="dv">2</span>][<span class="dv">5</span>] = {</a>
<a class="sourceLine" id="cb1-168" title="168">    {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb1-169" title="169">    {<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">0</span>}</a>
<a class="sourceLine" id="cb1-170" title="170">  };</a>
<a class="sourceLine" id="cb1-171" title="171">  <span class="co">// access elements:</span></a>
<a class="sourceLine" id="cb1-172" title="172">  <span class="dt">int</span> array_int = multi_array[<span class="dv">0</span>][<span class="dv">2</span>]; <span class="co">// =&gt; 3</span></a>
<a class="sourceLine" id="cb1-173" title="173"></a>
<a class="sourceLine" id="cb1-174" title="174">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-175" title="175">  <span class="co">// Operators</span></a>
<a class="sourceLine" id="cb1-176" title="176">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-177" title="177"></a>
<a class="sourceLine" id="cb1-178" title="178">  <span class="co">// Shorthands for multiple declarations:</span></a>
<a class="sourceLine" id="cb1-179" title="179">  <span class="dt">int</span> i1 = <span class="dv">1</span>, i2 = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-180" title="180">  <span class="dt">float</span> f1 = <span class="fl">1.0</span>, f2 = <span class="fl">2.0</span>;</a>
<a class="sourceLine" id="cb1-181" title="181"></a>
<a class="sourceLine" id="cb1-182" title="182">  <span class="dt">int</span> b, c;</a>
<a class="sourceLine" id="cb1-183" title="183">  b = c = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185">  <span class="co">// Arithmetic is straightforward</span></a>
<a class="sourceLine" id="cb1-186" title="186">  i1 + i2; <span class="co">// =&gt; 3</span></a>
<a class="sourceLine" id="cb1-187" title="187">  i2 - i1; <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb1-188" title="188">  i2 * i1; <span class="co">// =&gt; 2</span></a>
<a class="sourceLine" id="cb1-189" title="189">  i1 / i2; <span class="co">// =&gt; 0 (0.5, but truncated towards 0)</span></a>
<a class="sourceLine" id="cb1-190" title="190"></a>
<a class="sourceLine" id="cb1-191" title="191">  <span class="co">// You need to cast at least one integer to float to get a floating-point result</span></a>
<a class="sourceLine" id="cb1-192" title="192">  (<span class="dt">float</span>)i1 / i2; <span class="co">// =&gt; 0.5f</span></a>
<a class="sourceLine" id="cb1-193" title="193">  i1 / (<span class="dt">double</span>)i2; <span class="co">// =&gt; 0.5 // Same with double</span></a>
<a class="sourceLine" id="cb1-194" title="194">  f1 / f2; <span class="co">// =&gt; 0.5, plus or minus epsilon</span></a>
<a class="sourceLine" id="cb1-195" title="195">  </a>
<a class="sourceLine" id="cb1-196" title="196">  <span class="co">// Floating-point numbers and calculations are not exact</span></a>
<a class="sourceLine" id="cb1-197" title="197">  <span class="co">// for instance it is not giving mathematically correct results</span></a>
<a class="sourceLine" id="cb1-198" title="198">  (<span class="fl">0.1</span> + <span class="fl">0.1</span> + <span class="fl">0.1</span>) != <span class="fl">0.3</span>; <span class="co">// =&gt; 1 (true)</span></a>
<a class="sourceLine" id="cb1-199" title="199">  <span class="co">// and it is NOT associative</span></a>
<a class="sourceLine" id="cb1-200" title="200">  <span class="dv">1</span> + (<span class="fl">1e123</span> - <span class="fl">1e123</span>) != (<span class="dv">1</span> + <span class="fl">1e123</span>) - <span class="fl">1e123</span>; <span class="co">// =&gt; 1 (true)</span></a>
<a class="sourceLine" id="cb1-201" title="201">  <span class="co">// this notation is scientific notations for numbers: 1e123 = 1*10^123</span></a>
<a class="sourceLine" id="cb1-202" title="202"></a>
<a class="sourceLine" id="cb1-203" title="203">  <span class="co">// Modulo is there as well, but be careful if arguments are negative</span></a>
<a class="sourceLine" id="cb1-204" title="204">  <span class="dv">11</span> % <span class="dv">3</span>;    <span class="co">// =&gt; 2 as 11 = 2 + 3*x (x=3)</span></a>
<a class="sourceLine" id="cb1-205" title="205">  (-<span class="dv">11</span>) % <span class="dv">3</span>; <span class="co">// =&gt; -2, as one would expect</span></a>
<a class="sourceLine" id="cb1-206" title="206">  <span class="dv">11</span> % (-<span class="dv">3</span>); <span class="co">// =&gt; 2 and not -2, and it&#39;s quite counter intuitive</span></a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208">  <span class="co">// Comparison operators are probably familiar, but</span></a>
<a class="sourceLine" id="cb1-209" title="209">  <span class="co">// there is no Boolean type in C. We use ints instead.</span></a>
<a class="sourceLine" id="cb1-210" title="210">  <span class="co">// (Or _Bool or bool in C99.)</span></a>
<a class="sourceLine" id="cb1-211" title="211">  <span class="co">// 0 is false, anything else is true. (The comparison</span></a>
<a class="sourceLine" id="cb1-212" title="212">  <span class="co">// operators always yield 0 or 1.)</span></a>
<a class="sourceLine" id="cb1-213" title="213">  <span class="dv">3</span> == <span class="dv">2</span>; <span class="co">// =&gt; 0 (false)</span></a>
<a class="sourceLine" id="cb1-214" title="214">  <span class="dv">3</span> != <span class="dv">2</span>; <span class="co">// =&gt; 1 (true)</span></a>
<a class="sourceLine" id="cb1-215" title="215">  <span class="dv">3</span> &gt; <span class="dv">2</span>;  <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb1-216" title="216">  <span class="dv">3</span> &lt; <span class="dv">2</span>;  <span class="co">// =&gt; 0</span></a>
<a class="sourceLine" id="cb1-217" title="217">  <span class="dv">2</span> &lt;= <span class="dv">2</span>; <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb1-218" title="218">  <span class="dv">2</span> &gt;= <span class="dv">2</span>; <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220">  <span class="co">// C is not Python - comparisons do NOT chain.</span></a>
<a class="sourceLine" id="cb1-221" title="221">  <span class="co">// Warning: The line below will compile, but it means `(0 &lt; a) &lt; 2`.</span></a>
<a class="sourceLine" id="cb1-222" title="222">  <span class="co">// This expression is always true, because (0 &lt; a) could be either 1 or 0.</span></a>
<a class="sourceLine" id="cb1-223" title="223">  <span class="co">// In this case it&#39;s 1, because (0 &lt; 1).</span></a>
<a class="sourceLine" id="cb1-224" title="224">  <span class="dt">int</span> between_0_and_2 = <span class="dv">0</span> &lt; a &lt; <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-225" title="225">  <span class="co">// Instead use:</span></a>
<a class="sourceLine" id="cb1-226" title="226">  <span class="dt">int</span> between_0_and_2 = <span class="dv">0</span> &lt; a &amp;&amp; a &lt; <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-227" title="227"></a>
<a class="sourceLine" id="cb1-228" title="228">  <span class="co">// Logic works on ints</span></a>
<a class="sourceLine" id="cb1-229" title="229">  !<span class="dv">3</span>; <span class="co">// =&gt; 0 (Logical not)</span></a>
<a class="sourceLine" id="cb1-230" title="230">  !<span class="dv">0</span>; <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb1-231" title="231">  <span class="dv">1</span> &amp;&amp; <span class="dv">1</span>; <span class="co">// =&gt; 1 (Logical and)</span></a>
<a class="sourceLine" id="cb1-232" title="232">  <span class="dv">0</span> &amp;&amp; <span class="dv">1</span>; <span class="co">// =&gt; 0</span></a>
<a class="sourceLine" id="cb1-233" title="233">  <span class="dv">0</span> || <span class="dv">1</span>; <span class="co">// =&gt; 1 (Logical or)</span></a>
<a class="sourceLine" id="cb1-234" title="234">  <span class="dv">0</span> || <span class="dv">0</span>; <span class="co">// =&gt; 0</span></a>
<a class="sourceLine" id="cb1-235" title="235"></a>
<a class="sourceLine" id="cb1-236" title="236">  <span class="co">// Conditional ternary expression ( ? : )</span></a>
<a class="sourceLine" id="cb1-237" title="237">  <span class="dt">int</span> e = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-238" title="238">  <span class="dt">int</span> f = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb1-239" title="239">  <span class="dt">int</span> z;</a>
<a class="sourceLine" id="cb1-240" title="240">  z = (e &gt; f) ? e : f; <span class="co">// =&gt; 10 &quot;if e &gt; f return e, else return f.&quot;</span></a>
<a class="sourceLine" id="cb1-241" title="241"></a>
<a class="sourceLine" id="cb1-242" title="242">  <span class="co">// Increment and decrement operators:</span></a>
<a class="sourceLine" id="cb1-243" title="243">  <span class="dt">int</span> j = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-244" title="244">  <span class="dt">int</span> s = j++; <span class="co">// Return j THEN increase j. (s = 0, j = 1)</span></a>
<a class="sourceLine" id="cb1-245" title="245">  s = ++j; <span class="co">// Increase j THEN return j. (s = 2, j = 2)</span></a>
<a class="sourceLine" id="cb1-246" title="246">  <span class="co">// same with j-- and --j</span></a>
<a class="sourceLine" id="cb1-247" title="247"></a>
<a class="sourceLine" id="cb1-248" title="248">  <span class="co">// Bitwise operators!</span></a>
<a class="sourceLine" id="cb1-249" title="249">  ~<span class="bn">0x0F</span>; <span class="co">// =&gt; 0xFFFFFFF0 (bitwise negation, &quot;1&#39;s complement&quot;, example result for 32-bit int)</span></a>
<a class="sourceLine" id="cb1-250" title="250">  <span class="bn">0x0F</span> &amp; <span class="bn">0xF0</span>; <span class="co">// =&gt; 0x00 (bitwise AND)</span></a>
<a class="sourceLine" id="cb1-251" title="251">  <span class="bn">0x0F</span> | <span class="bn">0xF0</span>; <span class="co">// =&gt; 0xFF (bitwise OR)</span></a>
<a class="sourceLine" id="cb1-252" title="252">  <span class="bn">0x04</span> ^ <span class="bn">0x0F</span>; <span class="co">// =&gt; 0x0B (bitwise XOR)</span></a>
<a class="sourceLine" id="cb1-253" title="253">  <span class="bn">0x01</span> &lt;&lt; <span class="dv">1</span>; <span class="co">// =&gt; 0x02 (bitwise left shift (by 1))</span></a>
<a class="sourceLine" id="cb1-254" title="254">  <span class="bn">0x02</span> &gt;&gt; <span class="dv">1</span>; <span class="co">// =&gt; 0x01 (bitwise right shift (by 1))</span></a>
<a class="sourceLine" id="cb1-255" title="255"></a>
<a class="sourceLine" id="cb1-256" title="256">  <span class="co">// Be careful when shifting signed integers - the following are undefined:</span></a>
<a class="sourceLine" id="cb1-257" title="257">  <span class="co">// - shifting into the sign bit of a signed integer (int a = 1 &lt;&lt; 31)</span></a>
<a class="sourceLine" id="cb1-258" title="258">  <span class="co">// - left-shifting a negative number (int a = -1 &lt;&lt; 2)</span></a>
<a class="sourceLine" id="cb1-259" title="259">  <span class="co">// - shifting by an offset which is &gt;= the width of the type of the LHS:</span></a>
<a class="sourceLine" id="cb1-260" title="260">  <span class="co">//   int a = 1 &lt;&lt; 32; // UB if int is 32 bits wide</span></a>
<a class="sourceLine" id="cb1-261" title="261"></a>
<a class="sourceLine" id="cb1-262" title="262">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-263" title="263">  <span class="co">// Control Structures</span></a>
<a class="sourceLine" id="cb1-264" title="264">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-265" title="265"></a>
<a class="sourceLine" id="cb1-266" title="266">  <span class="cf">if</span> (<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb1-267" title="267">    printf(<span class="st">&quot;I am never run</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-268" title="268">  } <span class="cf">else</span> <span class="cf">if</span> (<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb1-269" title="269">    printf(<span class="st">&quot;I am also never run</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-270" title="270">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-271" title="271">    printf(<span class="st">&quot;I print</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-272" title="272">  }</a>
<a class="sourceLine" id="cb1-273" title="273"></a>
<a class="sourceLine" id="cb1-274" title="274">  <span class="co">// While loops exist</span></a>
<a class="sourceLine" id="cb1-275" title="275">  <span class="dt">int</span> ii = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-276" title="276">  <span class="cf">while</span> (ii &lt; <span class="dv">10</span>) { <span class="co">//ANY value less than ten is true.</span></a>
<a class="sourceLine" id="cb1-277" title="277">    printf(<span class="st">&quot;%d, &quot;</span>, ii++); <span class="co">// ii++ increments ii AFTER using its current value.</span></a>
<a class="sourceLine" id="cb1-278" title="278">  } <span class="co">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span></a>
<a class="sourceLine" id="cb1-279" title="279"></a>
<a class="sourceLine" id="cb1-280" title="280">  printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-281" title="281"></a>
<a class="sourceLine" id="cb1-282" title="282">  <span class="dt">int</span> kk = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-283" title="283">  <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb1-284" title="284">    printf(<span class="st">&quot;%d, &quot;</span>, kk);</a>
<a class="sourceLine" id="cb1-285" title="285">  } <span class="cf">while</span> (++kk &lt; <span class="dv">10</span>); <span class="co">// ++kk increments kk BEFORE using its current value.</span></a>
<a class="sourceLine" id="cb1-286" title="286">  <span class="co">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span></a>
<a class="sourceLine" id="cb1-287" title="287"></a>
<a class="sourceLine" id="cb1-288" title="288">  printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-289" title="289"></a>
<a class="sourceLine" id="cb1-290" title="290">  <span class="co">// For loops too</span></a>
<a class="sourceLine" id="cb1-291" title="291">  <span class="dt">int</span> jj;</a>
<a class="sourceLine" id="cb1-292" title="292">  <span class="cf">for</span> (jj=<span class="dv">0</span>; jj &lt; <span class="dv">10</span>; jj++) {</a>
<a class="sourceLine" id="cb1-293" title="293">    printf(<span class="st">&quot;%d, &quot;</span>, jj);</a>
<a class="sourceLine" id="cb1-294" title="294">  } <span class="co">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span></a>
<a class="sourceLine" id="cb1-295" title="295"></a>
<a class="sourceLine" id="cb1-296" title="296">  printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-297" title="297"></a>
<a class="sourceLine" id="cb1-298" title="298">  <span class="co">// *****NOTES*****:</span></a>
<a class="sourceLine" id="cb1-299" title="299">  <span class="co">// Loops and Functions MUST have a body. If no body is needed:</span></a>
<a class="sourceLine" id="cb1-300" title="300">  <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb1-301" title="301">  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb1-302" title="302">    ; <span class="co">// use semicolon to act as the body (null statement)</span></a>
<a class="sourceLine" id="cb1-303" title="303">  }</a>
<a class="sourceLine" id="cb1-304" title="304">  <span class="co">// Or</span></a>
<a class="sourceLine" id="cb1-305" title="305">  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">5</span>; i++);</a>
<a class="sourceLine" id="cb1-306" title="306"></a>
<a class="sourceLine" id="cb1-307" title="307">  <span class="co">// branching with multiple choices: switch()</span></a>
<a class="sourceLine" id="cb1-308" title="308">  <span class="cf">switch</span> (a) {</a>
<a class="sourceLine" id="cb1-309" title="309">  <span class="cf">case</span> <span class="dv">0</span>: <span class="co">// labels need to be integral *constant* expressions (such as enums)</span></a>
<a class="sourceLine" id="cb1-310" title="310">    printf(<span class="st">&quot;Hey, &#39;a&#39; equals 0!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-311" title="311">    <span class="cf">break</span>; <span class="co">// if you don&#39;t break, control flow falls over labels</span></a>
<a class="sourceLine" id="cb1-312" title="312">  <span class="cf">case</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-313" title="313">    printf(<span class="st">&quot;Huh, &#39;a&#39; equals 1!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-314" title="314">    <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-315" title="315">    <span class="co">// Be careful - without a &quot;break&quot;, execution continues until the</span></a>
<a class="sourceLine" id="cb1-316" title="316">    <span class="co">// next &quot;break&quot; is reached.</span></a>
<a class="sourceLine" id="cb1-317" title="317">  <span class="cf">case</span> <span class="dv">3</span>:</a>
<a class="sourceLine" id="cb1-318" title="318">  <span class="cf">case</span> <span class="dv">4</span>:</a>
<a class="sourceLine" id="cb1-319" title="319">    printf(<span class="st">&quot;Look at that.. &#39;a&#39; is either 3, or 4</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-320" title="320">    <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-321" title="321">  <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb1-322" title="322">    <span class="co">// if `some_integral_expression` didn&#39;t match any of the labels</span></a>
<a class="sourceLine" id="cb1-323" title="323">    fputs(<span class="st">&quot;Error!</span><span class="sc">\n</span><span class="st">&quot;</span>, stderr);</a>
<a class="sourceLine" id="cb1-324" title="324">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-325" title="325">    <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-326" title="326">  }</a>
<a class="sourceLine" id="cb1-327" title="327">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-328" title="328"><span class="co">    Using &quot;goto&quot; in C</span></a>
<a class="sourceLine" id="cb1-329" title="329"><span class="co">  */</span></a>
<a class="sourceLine" id="cb1-330" title="330">  <span class="kw">typedef</span> <span class="kw">enum</span> { false, true } <span class="dt">bool</span>;</a>
<a class="sourceLine" id="cb1-331" title="331">  <span class="co">// for C don&#39;t have bool as data type before C99 :(</span></a>
<a class="sourceLine" id="cb1-332" title="332">  <span class="dt">bool</span> disaster = false;</a>
<a class="sourceLine" id="cb1-333" title="333">  <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb1-334" title="334">  <span class="cf">for</span>(i=<span class="dv">0</span>; i&lt;<span class="dv">100</span>; ++i)</a>
<a class="sourceLine" id="cb1-335" title="335">  <span class="cf">for</span>(j=<span class="dv">0</span>; j&lt;<span class="dv">100</span>; ++j)</a>
<a class="sourceLine" id="cb1-336" title="336">  {</a>
<a class="sourceLine" id="cb1-337" title="337">    <span class="cf">if</span>((i + j) &gt;= <span class="dv">150</span>)</a>
<a class="sourceLine" id="cb1-338" title="338">        disaster = true;</a>
<a class="sourceLine" id="cb1-339" title="339">    <span class="cf">if</span>(disaster)</a>
<a class="sourceLine" id="cb1-340" title="340">        <span class="cf">goto</span> error;  <span class="co">// exit both for loops</span></a>
<a class="sourceLine" id="cb1-341" title="341">  }</a>
<a class="sourceLine" id="cb1-342" title="342">  error: <span class="co">// this is a label that you can &quot;jump&quot; to with &quot;goto error;&quot;</span></a>
<a class="sourceLine" id="cb1-343" title="343">  printf(<span class="st">&quot;Error occurred at i = %d &amp; j = %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, i, j);</a>
<a class="sourceLine" id="cb1-344" title="344">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-345" title="345"><span class="co">    https://ideone.com/GuPhd6</span></a>
<a class="sourceLine" id="cb1-346" title="346"><span class="co">    this will print out &quot;Error occurred at i = 51 &amp; j = 99.&quot;</span></a>
<a class="sourceLine" id="cb1-347" title="347"><span class="co">  */</span></a>
<a class="sourceLine" id="cb1-348" title="348">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-349" title="349"><span class="co">    it is generally considered bad practice to do so, except if</span></a>
<a class="sourceLine" id="cb1-350" title="350"><span class="co">    you really know what you are doing. See </span></a>
<a class="sourceLine" id="cb1-351" title="351"><span class="co">    https://en.wikipedia.org/wiki/Spaghetti_code#Meaning</span></a>
<a class="sourceLine" id="cb1-352" title="352"><span class="co">  */</span></a>
<a class="sourceLine" id="cb1-353" title="353"></a>
<a class="sourceLine" id="cb1-354" title="354">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-355" title="355">  <span class="co">// Typecasting</span></a>
<a class="sourceLine" id="cb1-356" title="356">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-357" title="357"></a>
<a class="sourceLine" id="cb1-358" title="358">  <span class="co">// Every value in C has a type, but you can cast one value into another type</span></a>
<a class="sourceLine" id="cb1-359" title="359">  <span class="co">// if you want (with some constraints).</span></a>
<a class="sourceLine" id="cb1-360" title="360"></a>
<a class="sourceLine" id="cb1-361" title="361">  <span class="dt">int</span> x_hex = <span class="bn">0x01</span>; <span class="co">// You can assign vars with hex literals</span></a>
<a class="sourceLine" id="cb1-362" title="362"></a>
<a class="sourceLine" id="cb1-363" title="363">  <span class="co">// Casting between types will attempt to preserve their numeric values</span></a>
<a class="sourceLine" id="cb1-364" title="364">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, x_hex); <span class="co">// =&gt; Prints 1</span></a>
<a class="sourceLine" id="cb1-365" title="365">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">short</span>) x_hex); <span class="co">// =&gt; Prints 1</span></a>
<a class="sourceLine" id="cb1-366" title="366">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">char</span>) x_hex); <span class="co">// =&gt; Prints 1</span></a>
<a class="sourceLine" id="cb1-367" title="367"></a>
<a class="sourceLine" id="cb1-368" title="368">  <span class="co">// Types will overflow without warning</span></a>
<a class="sourceLine" id="cb1-369" title="369">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">unsigned</span> <span class="dt">char</span>) <span class="dv">257</span>); <span class="co">// =&gt; 1 (Max char = 255 if char is 8 bits long)</span></a>
<a class="sourceLine" id="cb1-370" title="370"></a>
<a class="sourceLine" id="cb1-371" title="371">  <span class="co">// For determining the max value of a `char`, a `signed char` and an `unsigned char`,</span></a>
<a class="sourceLine" id="cb1-372" title="372">  <span class="co">// respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from &lt;limits.h&gt;</span></a>
<a class="sourceLine" id="cb1-373" title="373"></a>
<a class="sourceLine" id="cb1-374" title="374">  <span class="co">// Integral types can be cast to floating-point types, and vice-versa.</span></a>
<a class="sourceLine" id="cb1-375" title="375">  printf(<span class="st">&quot;%f</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">double</span>) <span class="dv">100</span>); <span class="co">// %f always formats a double...</span></a>
<a class="sourceLine" id="cb1-376" title="376">  printf(<span class="st">&quot;%f</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">float</span>)  <span class="dv">100</span>); <span class="co">// ...even with a float.</span></a>
<a class="sourceLine" id="cb1-377" title="377">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">char</span>)<span class="fl">100.0</span>);</a>
<a class="sourceLine" id="cb1-378" title="378"></a>
<a class="sourceLine" id="cb1-379" title="379">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-380" title="380">  <span class="co">// Pointers</span></a>
<a class="sourceLine" id="cb1-381" title="381">  <span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-382" title="382"></a>
<a class="sourceLine" id="cb1-383" title="383">  <span class="co">// A pointer is a variable declared to store a memory address. Its declaration will</span></a>
<a class="sourceLine" id="cb1-384" title="384">  <span class="co">// also tell you the type of data it points to. You can retrieve the memory address</span></a>
<a class="sourceLine" id="cb1-385" title="385">  <span class="co">// of your variables, then mess with them.</span></a>
<a class="sourceLine" id="cb1-386" title="386"></a>
<a class="sourceLine" id="cb1-387" title="387">  <span class="dt">int</span> x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-388" title="388">  printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">void</span> *)&amp;x); <span class="co">// Use &amp; to retrieve the address of a variable</span></a>
<a class="sourceLine" id="cb1-389" title="389">  <span class="co">// (%p formats an object pointer of type void *)</span></a>
<a class="sourceLine" id="cb1-390" title="390">  <span class="co">// =&gt; Prints some address in memory;</span></a>
<a class="sourceLine" id="cb1-391" title="391"></a>
<a class="sourceLine" id="cb1-392" title="392">  <span class="co">// Pointers start with * in their declaration</span></a>
<a class="sourceLine" id="cb1-393" title="393">  <span class="dt">int</span> *px, not_a_pointer; <span class="co">// px is a pointer to an int</span></a>
<a class="sourceLine" id="cb1-394" title="394">  px = &amp;x; <span class="co">// Stores the address of x in px</span></a>
<a class="sourceLine" id="cb1-395" title="395">  printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">void</span> *)px); <span class="co">// =&gt; Prints some address in memory</span></a>
<a class="sourceLine" id="cb1-396" title="396">  printf(<span class="st">&quot;%zu, %zu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(px), <span class="kw">sizeof</span>(not_a_pointer));</a>
<a class="sourceLine" id="cb1-397" title="397">  <span class="co">// =&gt; Prints &quot;8, 4&quot; on a typical 64-bit system</span></a>
<a class="sourceLine" id="cb1-398" title="398"></a>
<a class="sourceLine" id="cb1-399" title="399">  <span class="co">// To retrieve the value at the address a pointer is pointing to,</span></a>
<a class="sourceLine" id="cb1-400" title="400">  <span class="co">// put * in front to dereference it.</span></a>
<a class="sourceLine" id="cb1-401" title="401">  <span class="co">// Note: yes, it may be confusing that &#39;*&#39; is used for _both_ declaring a</span></a>
<a class="sourceLine" id="cb1-402" title="402">  <span class="co">// pointer and dereferencing it.</span></a>
<a class="sourceLine" id="cb1-403" title="403">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *px); <span class="co">// =&gt; Prints 0, the value of x</span></a>
<a class="sourceLine" id="cb1-404" title="404"></a>
<a class="sourceLine" id="cb1-405" title="405">  <span class="co">// You can also change the value the pointer is pointing to.</span></a>
<a class="sourceLine" id="cb1-406" title="406">  <span class="co">// We&#39;ll have to wrap the dereference in parenthesis because</span></a>
<a class="sourceLine" id="cb1-407" title="407">  <span class="co">// ++ has a higher precedence than *.</span></a>
<a class="sourceLine" id="cb1-408" title="408">  (*px)++; <span class="co">// Increment the value px is pointing to by 1</span></a>
<a class="sourceLine" id="cb1-409" title="409">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *px); <span class="co">// =&gt; Prints 1</span></a>
<a class="sourceLine" id="cb1-410" title="410">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, x); <span class="co">// =&gt; Prints 1</span></a>
<a class="sourceLine" id="cb1-411" title="411"></a>
<a class="sourceLine" id="cb1-412" title="412">  <span class="co">// Arrays are a good way to allocate a contiguous block of memory</span></a>
<a class="sourceLine" id="cb1-413" title="413">  <span class="dt">int</span> x_array[<span class="dv">20</span>]; <span class="co">//declares array of size 20 (cannot change size)</span></a>
<a class="sourceLine" id="cb1-414" title="414">  <span class="dt">int</span> xx;</a>
<a class="sourceLine" id="cb1-415" title="415">  <span class="cf">for</span> (xx = <span class="dv">0</span>; xx &lt; <span class="dv">20</span>; xx++) {</a>
<a class="sourceLine" id="cb1-416" title="416">    x_array[xx] = <span class="dv">20</span> - xx;</a>
<a class="sourceLine" id="cb1-417" title="417">  } <span class="co">// Initialize x_array to 20, 19, 18,... 2, 1</span></a>
<a class="sourceLine" id="cb1-418" title="418"></a>
<a class="sourceLine" id="cb1-419" title="419">  <span class="co">// Declare a pointer of type int and initialize it to point to x_array</span></a>
<a class="sourceLine" id="cb1-420" title="420">  <span class="dt">int</span>* x_ptr = x_array;</a>
<a class="sourceLine" id="cb1-421" title="421">  <span class="co">// x_ptr now points to the first element in the array (the integer 20).</span></a>
<a class="sourceLine" id="cb1-422" title="422">  <span class="co">// This works because arrays often decay into pointers to their first element.</span></a>
<a class="sourceLine" id="cb1-423" title="423">  <span class="co">// For example, when an array is passed to a function or is assigned to a pointer,</span></a>
<a class="sourceLine" id="cb1-424" title="424">  <span class="co">// it decays into (implicitly converted to) a pointer.</span></a>
<a class="sourceLine" id="cb1-425" title="425">  <span class="co">// Exceptions: when the array is the argument of the `&amp;` (address-of) operator:</span></a>
<a class="sourceLine" id="cb1-426" title="426">  <span class="dt">int</span> arr[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb1-427" title="427">  <span class="dt">int</span> (*ptr_to_arr)[<span class="dv">10</span>] = &amp;arr; <span class="co">// &amp;arr is NOT of type `int *`!</span></a>
<a class="sourceLine" id="cb1-428" title="428">  <span class="co">// It&#39;s of type &quot;pointer to array&quot; (of ten `int`s).</span></a>
<a class="sourceLine" id="cb1-429" title="429">  <span class="co">// or when the array is a string literal used for initializing a char array:</span></a>
<a class="sourceLine" id="cb1-430" title="430">  <span class="dt">char</span> otherarr[] = <span class="st">&quot;foobarbazquirk&quot;</span>;</a>
<a class="sourceLine" id="cb1-431" title="431">  <span class="co">// or when it&#39;s the argument of the `sizeof` or `alignof` operator:</span></a>
<a class="sourceLine" id="cb1-432" title="432">  <span class="dt">int</span> arraythethird[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb1-433" title="433">  <span class="dt">int</span> *ptr = arraythethird; <span class="co">// equivalent with int *ptr = &amp;arr[0];</span></a>
<a class="sourceLine" id="cb1-434" title="434">  printf(<span class="st">&quot;%zu, %zu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(arraythethird), <span class="kw">sizeof</span>(ptr));</a>
<a class="sourceLine" id="cb1-435" title="435">  <span class="co">// probably prints &quot;40, 4&quot; or &quot;40, 8&quot;</span></a>
<a class="sourceLine" id="cb1-436" title="436"></a>
<a class="sourceLine" id="cb1-437" title="437">  <span class="co">// Pointers are incremented and decremented based on their type</span></a>
<a class="sourceLine" id="cb1-438" title="438">  <span class="co">// (this is called pointer arithmetic)</span></a>
<a class="sourceLine" id="cb1-439" title="439">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *(x_ptr + <span class="dv">1</span>)); <span class="co">// =&gt; Prints 19</span></a>
<a class="sourceLine" id="cb1-440" title="440">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, x_array[<span class="dv">1</span>]); <span class="co">// =&gt; Prints 19</span></a>
<a class="sourceLine" id="cb1-441" title="441"></a>
<a class="sourceLine" id="cb1-442" title="442">  <span class="co">// You can also dynamically allocate contiguous blocks of memory with the</span></a>
<a class="sourceLine" id="cb1-443" title="443">  <span class="co">// standard library function malloc, which takes one argument of type size_t</span></a>
<a class="sourceLine" id="cb1-444" title="444">  <span class="co">// representing the number of bytes to allocate (usually from the heap, although this</span></a>
<a class="sourceLine" id="cb1-445" title="445">  <span class="co">// may not be true on e.g. embedded systems - the C standard says nothing about it).</span></a>
<a class="sourceLine" id="cb1-446" title="446">  <span class="dt">int</span> *my_ptr = malloc(<span class="kw">sizeof</span>(*my_ptr) * <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1-447" title="447">  <span class="cf">for</span> (xx = <span class="dv">0</span>; xx &lt; <span class="dv">20</span>; xx++) {</a>
<a class="sourceLine" id="cb1-448" title="448">    *(my_ptr + xx) = <span class="dv">20</span> - xx; <span class="co">// my_ptr[xx] = 20-xx</span></a>
<a class="sourceLine" id="cb1-449" title="449">  } <span class="co">// Initialize memory to 20, 19, 18, 17... 2, 1 (as ints)</span></a>
<a class="sourceLine" id="cb1-450" title="450"></a>
<a class="sourceLine" id="cb1-451" title="451">  <span class="co">// Be careful passing user-provided values to malloc! If you want</span></a>
<a class="sourceLine" id="cb1-452" title="452">  <span class="co">// to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory)</span></a>
<a class="sourceLine" id="cb1-453" title="453">  <span class="dt">int</span>* my_other_ptr = calloc(<span class="dv">20</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb1-454" title="454"></a>
<a class="sourceLine" id="cb1-455" title="455">  <span class="co">// Note that there is no standard way to get the length of a</span></a>
<a class="sourceLine" id="cb1-456" title="456">  <span class="co">// dynamically allocated array in C. Because of this, if your arrays are</span></a>
<a class="sourceLine" id="cb1-457" title="457">  <span class="co">// going to be passed around your program a lot, you need another variable</span></a>
<a class="sourceLine" id="cb1-458" title="458">  <span class="co">// to keep track of the number of elements (size) of an array. See the</span></a>
<a class="sourceLine" id="cb1-459" title="459">  <span class="co">// functions section for more info.</span></a>
<a class="sourceLine" id="cb1-460" title="460">  <span class="dt">size_t</span> size = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb1-461" title="461">  <span class="dt">int</span> *my_arr = calloc(size, <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb1-462" title="462">  <span class="co">// Add an element to the array</span></a>
<a class="sourceLine" id="cb1-463" title="463">  size++;</a>
<a class="sourceLine" id="cb1-464" title="464">  my_arr = realloc(my_arr, <span class="kw">sizeof</span>(<span class="dt">int</span>) * size);</a>
<a class="sourceLine" id="cb1-465" title="465">  <span class="cf">if</span> (my_arr == NULL) {</a>
<a class="sourceLine" id="cb1-466" title="466">    <span class="co">//Remember to check for realloc failure!</span></a>
<a class="sourceLine" id="cb1-467" title="467">    <span class="cf">return</span></a>
<a class="sourceLine" id="cb1-468" title="468">  }</a>
<a class="sourceLine" id="cb1-469" title="469">  my_arr[<span class="dv">10</span>] = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-470" title="470"></a>
<a class="sourceLine" id="cb1-471" title="471">  <span class="co">// Dereferencing memory that you haven&#39;t allocated gives</span></a>
<a class="sourceLine" id="cb1-472" title="472">  <span class="co">// &quot;unpredictable results&quot; - the program is said to invoke &quot;undefined behavior&quot;</span></a>
<a class="sourceLine" id="cb1-473" title="473">  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *(my_ptr + <span class="dv">21</span>)); <span class="co">// =&gt; Prints who-knows-what? It may even crash.</span></a>
<a class="sourceLine" id="cb1-474" title="474"></a>
<a class="sourceLine" id="cb1-475" title="475">  <span class="co">// When you&#39;re done with a malloc&#39;d block of memory, you need to free it,</span></a>
<a class="sourceLine" id="cb1-476" title="476">  <span class="co">// or else no one else can use it until your program terminates</span></a>
<a class="sourceLine" id="cb1-477" title="477">  <span class="co">// (this is called a &quot;memory leak&quot;):</span></a>
<a class="sourceLine" id="cb1-478" title="478">  free(my_ptr);</a>
<a class="sourceLine" id="cb1-479" title="479"></a>
<a class="sourceLine" id="cb1-480" title="480">  <span class="co">// Strings are arrays of char, but they are usually represented as a</span></a>
<a class="sourceLine" id="cb1-481" title="481">  <span class="co">// pointer-to-char (which is a pointer to the first element of the array).</span></a>
<a class="sourceLine" id="cb1-482" title="482">  <span class="co">// It&#39;s good practice to use `const char *&#39; when referring to a string literal,</span></a>
<a class="sourceLine" id="cb1-483" title="483">  <span class="co">// since string literals shall not be modified (i.e. &quot;foo&quot;[0] = &#39;a&#39; is ILLEGAL.)</span></a>
<a class="sourceLine" id="cb1-484" title="484">  <span class="dt">const</span> <span class="dt">char</span> *my_str = <span class="st">&quot;This is my very own string literal&quot;</span>;</a>
<a class="sourceLine" id="cb1-485" title="485">  printf(<span class="st">&quot;%c</span><span class="sc">\n</span><span class="st">&quot;</span>, *my_str); <span class="co">// =&gt; &#39;T&#39;</span></a>
<a class="sourceLine" id="cb1-486" title="486"></a>
<a class="sourceLine" id="cb1-487" title="487">  <span class="co">// This is not the case if the string is an array</span></a>
<a class="sourceLine" id="cb1-488" title="488">  <span class="co">// (potentially initialized with a string literal)</span></a>
<a class="sourceLine" id="cb1-489" title="489">  <span class="co">// that resides in writable memory, as in:</span></a>
<a class="sourceLine" id="cb1-490" title="490">  <span class="dt">char</span> foo[] = <span class="st">&quot;foo&quot;</span>;</a>
<a class="sourceLine" id="cb1-491" title="491">  foo[<span class="dv">0</span>] = <span class="ch">&#39;a&#39;</span>; <span class="co">// this is legal, foo now contains &quot;aoo&quot;</span></a>
<a class="sourceLine" id="cb1-492" title="492"></a>
<a class="sourceLine" id="cb1-493" title="493">  function_1();</a>
<a class="sourceLine" id="cb1-494" title="494">} <span class="co">// end main function</span></a>
<a class="sourceLine" id="cb1-495" title="495"></a>
<a class="sourceLine" id="cb1-496" title="496"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-497" title="497"><span class="co">// Functions</span></a>
<a class="sourceLine" id="cb1-498" title="498"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-499" title="499"></a>
<a class="sourceLine" id="cb1-500" title="500"><span class="co">// Function declaration syntax:</span></a>
<a class="sourceLine" id="cb1-501" title="501"><span class="co">// &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;)</span></a>
<a class="sourceLine" id="cb1-502" title="502"></a>
<a class="sourceLine" id="cb1-503" title="503"><span class="dt">int</span> add_two_ints(<span class="dt">int</span> x1, <span class="dt">int</span> x2)</a>
<a class="sourceLine" id="cb1-504" title="504">{</a>
<a class="sourceLine" id="cb1-505" title="505">  <span class="cf">return</span> x1 + x2; <span class="co">// Use return to return a value</span></a>
<a class="sourceLine" id="cb1-506" title="506">}</a>
<a class="sourceLine" id="cb1-507" title="507"></a>
<a class="sourceLine" id="cb1-508" title="508"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-509" title="509"><span class="co">Functions are call by value. When a function is called, the arguments passed to</span></a>
<a class="sourceLine" id="cb1-510" title="510"><span class="co">the function are copies of the original arguments (except arrays). Anything you</span></a>
<a class="sourceLine" id="cb1-511" title="511"><span class="co">do to the arguments in the function do not change the value of the original</span></a>
<a class="sourceLine" id="cb1-512" title="512"><span class="co">argument where the function was called.</span></a>
<a class="sourceLine" id="cb1-513" title="513"></a>
<a class="sourceLine" id="cb1-514" title="514"><span class="co">Use pointers if you need to edit the original argument values.</span></a>
<a class="sourceLine" id="cb1-515" title="515"></a>
<a class="sourceLine" id="cb1-516" title="516"><span class="co">Example: in-place string reversal</span></a>
<a class="sourceLine" id="cb1-517" title="517"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-518" title="518"></a>
<a class="sourceLine" id="cb1-519" title="519"><span class="co">// A void function returns no value</span></a>
<a class="sourceLine" id="cb1-520" title="520"><span class="dt">void</span> str_reverse(<span class="dt">char</span> *str_in)</a>
<a class="sourceLine" id="cb1-521" title="521">{</a>
<a class="sourceLine" id="cb1-522" title="522">  <span class="dt">char</span> tmp;</a>
<a class="sourceLine" id="cb1-523" title="523">  <span class="dt">size_t</span> ii = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-524" title="524">  <span class="dt">size_t</span> len = strlen(str_in); <span class="co">// `strlen()` is part of the c standard library</span></a>
<a class="sourceLine" id="cb1-525" title="525">                               <span class="co">// </span><span class="al">NOTE</span><span class="co">: length returned by `strlen` DOESN&#39;T include the</span></a>
<a class="sourceLine" id="cb1-526" title="526">                               <span class="co">//       terminating NULL byte (&#39;\0&#39;)</span></a>
<a class="sourceLine" id="cb1-527" title="527">  <span class="cf">for</span> (ii = <span class="dv">0</span>; ii &lt; len / <span class="dv">2</span>; ii++) { <span class="co">// in C99 you can directly declare type of `ii` here</span></a>
<a class="sourceLine" id="cb1-528" title="528">    tmp = str_in[ii];</a>
<a class="sourceLine" id="cb1-529" title="529">    str_in[ii] = str_in[len - ii - <span class="dv">1</span>]; <span class="co">// ii-th char from end</span></a>
<a class="sourceLine" id="cb1-530" title="530">    str_in[len - ii - <span class="dv">1</span>] = tmp;</a>
<a class="sourceLine" id="cb1-531" title="531">  }</a>
<a class="sourceLine" id="cb1-532" title="532">}</a>
<a class="sourceLine" id="cb1-533" title="533"><span class="co">//</span><span class="al">NOTE</span><span class="co">: string.h header file needs to be included to use strlen()</span></a>
<a class="sourceLine" id="cb1-534" title="534"></a>
<a class="sourceLine" id="cb1-535" title="535"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-536" title="536"><span class="co">char c[] = &quot;This is a test.&quot;;</span></a>
<a class="sourceLine" id="cb1-537" title="537"><span class="co">str_reverse(c);</span></a>
<a class="sourceLine" id="cb1-538" title="538"><span class="co">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span></a>
<a class="sourceLine" id="cb1-539" title="539"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-540" title="540"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-541" title="541"><span class="co">as we can return only one variable</span></a>
<a class="sourceLine" id="cb1-542" title="542"><span class="co">to change values of more than one variables we use call by reference</span></a>
<a class="sourceLine" id="cb1-543" title="543"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-544" title="544"><span class="dt">void</span> swapTwoNumbers(<span class="dt">int</span> *a, <span class="dt">int</span> *b)</a>
<a class="sourceLine" id="cb1-545" title="545">{</a>
<a class="sourceLine" id="cb1-546" title="546">    <span class="dt">int</span> temp = *a;</a>
<a class="sourceLine" id="cb1-547" title="547">    *a = *b;</a>
<a class="sourceLine" id="cb1-548" title="548">    *b = temp;</a>
<a class="sourceLine" id="cb1-549" title="549">}</a>
<a class="sourceLine" id="cb1-550" title="550"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-551" title="551"><span class="co">int first = 10;</span></a>
<a class="sourceLine" id="cb1-552" title="552"><span class="co">int second = 20;</span></a>
<a class="sourceLine" id="cb1-553" title="553"><span class="co">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span></a>
<a class="sourceLine" id="cb1-554" title="554"><span class="co">swapTwoNumbers(&amp;first, &amp;second);</span></a>
<a class="sourceLine" id="cb1-555" title="555"><span class="co">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span></a>
<a class="sourceLine" id="cb1-556" title="556"><span class="co">// values will be swapped</span></a>
<a class="sourceLine" id="cb1-557" title="557"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-558" title="558"></a>
<a class="sourceLine" id="cb1-559" title="559"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-560" title="560"><span class="co">With regards to arrays, they will always be passed to functions</span></a>
<a class="sourceLine" id="cb1-561" title="561"><span class="co">as pointers. Even if you statically allocate an array like `arr[10]`,</span></a>
<a class="sourceLine" id="cb1-562" title="562"><span class="co">it still gets passed as a pointer to the first element in any function calls.</span></a>
<a class="sourceLine" id="cb1-563" title="563"><span class="co">Again, there is no standard way to get the size of a dynamically allocated</span></a>
<a class="sourceLine" id="cb1-564" title="564"><span class="co">array in C.</span></a>
<a class="sourceLine" id="cb1-565" title="565"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-566" title="566"><span class="co">// Size must be passed!</span></a>
<a class="sourceLine" id="cb1-567" title="567"><span class="co">// Otherwise, this function has no way of knowing how big the array is.</span></a>
<a class="sourceLine" id="cb1-568" title="568"><span class="dt">void</span> printIntArray(<span class="dt">int</span> *arr, <span class="dt">size_t</span> size) {</a>
<a class="sourceLine" id="cb1-569" title="569">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb1-570" title="570">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; size; i++) {</a>
<a class="sourceLine" id="cb1-571" title="571">        printf(<span class="st">&quot;arr[%d] is: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, i, arr[i]);</a>
<a class="sourceLine" id="cb1-572" title="572">    }</a>
<a class="sourceLine" id="cb1-573" title="573">}</a>
<a class="sourceLine" id="cb1-574" title="574"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-575" title="575"><span class="co">int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span></a>
<a class="sourceLine" id="cb1-576" title="576"><span class="co">int size = 10;</span></a>
<a class="sourceLine" id="cb1-577" title="577"><span class="co">printIntArray(my_arr, size);</span></a>
<a class="sourceLine" id="cb1-578" title="578"><span class="co">// will print &quot;arr[0] is: 1&quot; etc</span></a>
<a class="sourceLine" id="cb1-579" title="579"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-580" title="580"></a>
<a class="sourceLine" id="cb1-581" title="581"><span class="co">// if referring to external variables outside function, you should use the extern keyword.</span></a>
<a class="sourceLine" id="cb1-582" title="582"><span class="dt">int</span> i = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-583" title="583"><span class="dt">void</span> testFunc() {</a>
<a class="sourceLine" id="cb1-584" title="584">  <span class="kw">extern</span> <span class="dt">int</span> i; <span class="co">//i here is now using external variable i</span></a>
<a class="sourceLine" id="cb1-585" title="585">}</a>
<a class="sourceLine" id="cb1-586" title="586"></a>
<a class="sourceLine" id="cb1-587" title="587"><span class="co">// make external variables private to source file with static:</span></a>
<a class="sourceLine" id="cb1-588" title="588"><span class="dt">static</span> <span class="dt">int</span> j = <span class="dv">0</span>; <span class="co">//other files using testFunc2() cannot access variable j</span></a>
<a class="sourceLine" id="cb1-589" title="589"><span class="dt">void</span> testFunc2() {</a>
<a class="sourceLine" id="cb1-590" title="590">  <span class="kw">extern</span> <span class="dt">int</span> j;</a>
<a class="sourceLine" id="cb1-591" title="591">}</a>
<a class="sourceLine" id="cb1-592" title="592"><span class="co">// The static keyword makes a variable inaccessible to code outside the</span></a>
<a class="sourceLine" id="cb1-593" title="593"><span class="co">// compilation unit. (On almost all systems, a &quot;compilation unit&quot; is a .c</span></a>
<a class="sourceLine" id="cb1-594" title="594"><span class="co">// file.) static can apply both to global (to the compilation unit) variables,</span></a>
<a class="sourceLine" id="cb1-595" title="595"><span class="co">// functions, and function-local variables. When using static with</span></a>
<a class="sourceLine" id="cb1-596" title="596"><span class="co">// function-local variables, the variable is effectively global and retains its</span></a>
<a class="sourceLine" id="cb1-597" title="597"><span class="co">// value across function calls, but is only accessible within the function it</span></a>
<a class="sourceLine" id="cb1-598" title="598"><span class="co">// is declared in. Additionally, static variables are initialized to 0 if not</span></a>
<a class="sourceLine" id="cb1-599" title="599"><span class="co">// declared with some other starting value.</span></a>
<a class="sourceLine" id="cb1-600" title="600"><span class="co">//**You may also declare functions as static to make them private**</span></a>
<a class="sourceLine" id="cb1-601" title="601"></a>
<a class="sourceLine" id="cb1-602" title="602"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-603" title="603"><span class="co">// User-defined types and structs</span></a>
<a class="sourceLine" id="cb1-604" title="604"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-605" title="605"></a>
<a class="sourceLine" id="cb1-606" title="606"><span class="co">// Typedefs can be used to create type aliases</span></a>
<a class="sourceLine" id="cb1-607" title="607"><span class="kw">typedef</span> <span class="dt">int</span> my_type;</a>
<a class="sourceLine" id="cb1-608" title="608">my_type my_type_var = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-609" title="609"></a>
<a class="sourceLine" id="cb1-610" title="610"><span class="co">// Structs are just collections of data, the members are allocated sequentially,</span></a>
<a class="sourceLine" id="cb1-611" title="611"><span class="co">// in the order they are written:</span></a>
<a class="sourceLine" id="cb1-612" title="612"><span class="kw">struct</span> rectangle {</a>
<a class="sourceLine" id="cb1-613" title="613">  <span class="dt">int</span> width;</a>
<a class="sourceLine" id="cb1-614" title="614">  <span class="dt">int</span> height;</a>
<a class="sourceLine" id="cb1-615" title="615">};</a>
<a class="sourceLine" id="cb1-616" title="616"></a>
<a class="sourceLine" id="cb1-617" title="617"><span class="co">// It&#39;s not generally true that</span></a>
<a class="sourceLine" id="cb1-618" title="618"><span class="co">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span></a>
<a class="sourceLine" id="cb1-619" title="619"><span class="co">// due to potential padding between the structure members (this is for alignment</span></a>
<a class="sourceLine" id="cb1-620" title="620"><span class="co">// reasons). [1]</span></a>
<a class="sourceLine" id="cb1-621" title="621"></a>
<a class="sourceLine" id="cb1-622" title="622"><span class="dt">void</span> function_1()</a>
<a class="sourceLine" id="cb1-623" title="623">{</a>
<a class="sourceLine" id="cb1-624" title="624">  <span class="kw">struct</span> rectangle my_rec;</a>
<a class="sourceLine" id="cb1-625" title="625"></a>
<a class="sourceLine" id="cb1-626" title="626">  <span class="co">// Access struct members with .</span></a>
<a class="sourceLine" id="cb1-627" title="627">  my_rec.width = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb1-628" title="628">  my_rec.height = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb1-629" title="629"></a>
<a class="sourceLine" id="cb1-630" title="630">  <span class="co">// You can declare pointers to structs</span></a>
<a class="sourceLine" id="cb1-631" title="631">  <span class="kw">struct</span> rectangle *my_rec_ptr = &amp;my_rec;</a>
<a class="sourceLine" id="cb1-632" title="632"></a>
<a class="sourceLine" id="cb1-633" title="633">  <span class="co">// Use dereferencing to set struct pointer members...</span></a>
<a class="sourceLine" id="cb1-634" title="634">  (*my_rec_ptr).width = <span class="dv">30</span>;</a>
<a class="sourceLine" id="cb1-635" title="635"></a>
<a class="sourceLine" id="cb1-636" title="636">  <span class="co">// ... or even better: prefer the -&gt; shorthand for the sake of readability</span></a>
<a class="sourceLine" id="cb1-637" title="637">  my_rec_ptr-&gt;height = <span class="dv">10</span>; <span class="co">// Same as (*my_rec_ptr).height = 10;</span></a>
<a class="sourceLine" id="cb1-638" title="638">}</a>
<a class="sourceLine" id="cb1-639" title="639"></a>
<a class="sourceLine" id="cb1-640" title="640"><span class="co">// You can apply a typedef to a struct for convenience</span></a>
<a class="sourceLine" id="cb1-641" title="641"><span class="kw">typedef</span> <span class="kw">struct</span> rectangle rect;</a>
<a class="sourceLine" id="cb1-642" title="642"></a>
<a class="sourceLine" id="cb1-643" title="643"><span class="dt">int</span> area(rect r)</a>
<a class="sourceLine" id="cb1-644" title="644">{</a>
<a class="sourceLine" id="cb1-645" title="645">  <span class="cf">return</span> r.width * r.height;</a>
<a class="sourceLine" id="cb1-646" title="646">}</a>
<a class="sourceLine" id="cb1-647" title="647"></a>
<a class="sourceLine" id="cb1-648" title="648"><span class="co">// if you have large structs, you can pass them &quot;by pointer&quot; to avoid copying</span></a>
<a class="sourceLine" id="cb1-649" title="649"><span class="co">// the whole struct:</span></a>
<a class="sourceLine" id="cb1-650" title="650"><span class="dt">int</span> areaptr(<span class="dt">const</span> rect *r)</a>
<a class="sourceLine" id="cb1-651" title="651">{</a>
<a class="sourceLine" id="cb1-652" title="652">  <span class="cf">return</span> r-&gt;width * r-&gt;height;</a>
<a class="sourceLine" id="cb1-653" title="653">}</a>
<a class="sourceLine" id="cb1-654" title="654"></a>
<a class="sourceLine" id="cb1-655" title="655"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-656" title="656"><span class="co">// Function pointers</span></a>
<a class="sourceLine" id="cb1-657" title="657"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-658" title="658"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-659" title="659"><span class="co">At run time, functions are located at known memory addresses. Function pointers are</span></a>
<a class="sourceLine" id="cb1-660" title="660"><span class="co">much like any other pointer (they just store a memory address), but can be used</span></a>
<a class="sourceLine" id="cb1-661" title="661"><span class="co">to invoke functions directly, and to pass handlers (or callback functions) around.</span></a>
<a class="sourceLine" id="cb1-662" title="662"><span class="co">However, definition syntax may be initially confusing.</span></a>
<a class="sourceLine" id="cb1-663" title="663"></a>
<a class="sourceLine" id="cb1-664" title="664"><span class="co">Example: use str_reverse from a pointer</span></a>
<a class="sourceLine" id="cb1-665" title="665"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-666" title="666"><span class="dt">void</span> str_reverse_through_pointer(<span class="dt">char</span> *str_in) {</a>
<a class="sourceLine" id="cb1-667" title="667">  <span class="co">// Define a function pointer variable, named f.</span></a>
<a class="sourceLine" id="cb1-668" title="668">  <span class="dt">void</span> (*f)(<span class="dt">char</span> *); <span class="co">// Signature should exactly match the target function.</span></a>
<a class="sourceLine" id="cb1-669" title="669">  f = &amp;str_reverse; <span class="co">// Assign the address for the actual function (determined at run time)</span></a>
<a class="sourceLine" id="cb1-670" title="670">  <span class="co">// f = str_reverse; would work as well - functions decay into pointers, similar to arrays</span></a>
<a class="sourceLine" id="cb1-671" title="671">  (*f)(str_in); <span class="co">// Just calling the function through the pointer</span></a>
<a class="sourceLine" id="cb1-672" title="672">  <span class="co">// f(str_in); // That&#39;s an alternative but equally valid syntax for calling it.</span></a>
<a class="sourceLine" id="cb1-673" title="673">}</a>
<a class="sourceLine" id="cb1-674" title="674"></a>
<a class="sourceLine" id="cb1-675" title="675"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-676" title="676"><span class="co">As long as function signatures match, you can assign any function to the same pointer.</span></a>
<a class="sourceLine" id="cb1-677" title="677"><span class="co">Function pointers are usually typedef&#39;d for simplicity and readability, as follows:</span></a>
<a class="sourceLine" id="cb1-678" title="678"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-679" title="679"></a>
<a class="sourceLine" id="cb1-680" title="680"><span class="kw">typedef</span> <span class="dt">void</span> (*my_fnp_type)(<span class="dt">char</span> *);</a>
<a class="sourceLine" id="cb1-681" title="681"></a>
<a class="sourceLine" id="cb1-682" title="682"><span class="co">// Then used when declaring the actual pointer variable:</span></a>
<a class="sourceLine" id="cb1-683" title="683"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb1-684" title="684"><span class="co">// my_fnp_type f;</span></a>
<a class="sourceLine" id="cb1-685" title="685"></a>
<a class="sourceLine" id="cb1-686" title="686"></a>
<a class="sourceLine" id="cb1-687" title="687"><span class="co">//Special characters:</span></a>
<a class="sourceLine" id="cb1-688" title="688"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-689" title="689"><span class="co">&#39;\a&#39;; // alert (bell) character</span></a>
<a class="sourceLine" id="cb1-690" title="690"><span class="co">&#39;\n&#39;; // newline character</span></a>
<a class="sourceLine" id="cb1-691" title="691"><span class="co">&#39;\t&#39;; // tab character (left justifies text)</span></a>
<a class="sourceLine" id="cb1-692" title="692"><span class="co">&#39;\v&#39;; // vertical tab</span></a>
<a class="sourceLine" id="cb1-693" title="693"><span class="co">&#39;\f&#39;; // new page (form feed)</span></a>
<a class="sourceLine" id="cb1-694" title="694"><span class="co">&#39;\r&#39;; // carriage return</span></a>
<a class="sourceLine" id="cb1-695" title="695"><span class="co">&#39;\b&#39;; // backspace character</span></a>
<a class="sourceLine" id="cb1-696" title="696"><span class="co">&#39;\0&#39;; // NULL character. Usually put at end of strings in C.</span></a>
<a class="sourceLine" id="cb1-697" title="697"><span class="co">//   hello\n\0. \0 used by convention to mark end of string.</span></a>
<a class="sourceLine" id="cb1-698" title="698"><span class="co">&#39;\\&#39;; // backslash</span></a>
<a class="sourceLine" id="cb1-699" title="699"><span class="co">&#39;\?&#39;; // question mark</span></a>
<a class="sourceLine" id="cb1-700" title="700"><span class="co">&#39;\&#39;&#39;; // single quote</span></a>
<a class="sourceLine" id="cb1-701" title="701"><span class="co">&#39;\&quot;&#39;; // double quote</span></a>
<a class="sourceLine" id="cb1-702" title="702"><span class="co">&#39;\xhh&#39;; // hexadecimal number. Example: &#39;\xb&#39; = vertical tab character</span></a>
<a class="sourceLine" id="cb1-703" title="703"><span class="co">&#39;\0oo&#39;; // octal number. Example: &#39;\013&#39; = vertical tab character</span></a>
<a class="sourceLine" id="cb1-704" title="704"></a>
<a class="sourceLine" id="cb1-705" title="705"><span class="co">//print formatting:</span></a>
<a class="sourceLine" id="cb1-706" title="706"><span class="co">&quot;%d&quot;;    // integer</span></a>
<a class="sourceLine" id="cb1-707" title="707"><span class="co">&quot;%3d&quot;;   // integer with minimum of length 3 digits (right justifies text)</span></a>
<a class="sourceLine" id="cb1-708" title="708"><span class="co">&quot;%s&quot;;    // string</span></a>
<a class="sourceLine" id="cb1-709" title="709"><span class="co">&quot;%f&quot;;    // float</span></a>
<a class="sourceLine" id="cb1-710" title="710"><span class="co">&quot;%ld&quot;;   // long</span></a>
<a class="sourceLine" id="cb1-711" title="711"><span class="co">&quot;%3.2f&quot;; // minimum 3 digits left and 2 digits right decimal float</span></a>
<a class="sourceLine" id="cb1-712" title="712"><span class="co">&quot;%7.4s&quot;; // (can do with strings too)</span></a>
<a class="sourceLine" id="cb1-713" title="713"><span class="co">&quot;%c&quot;;    // char</span></a>
<a class="sourceLine" id="cb1-714" title="714"><span class="co">&quot;%p&quot;;    // pointer. </span><span class="al">NOTE</span><span class="co">: need to (void *)-cast the pointer, before passing</span></a>
<a class="sourceLine" id="cb1-715" title="715"><span class="co">         //                it as an argument to `printf`.</span></a>
<a class="sourceLine" id="cb1-716" title="716"><span class="co">&quot;%x&quot;;    // hexadecimal</span></a>
<a class="sourceLine" id="cb1-717" title="717"><span class="co">&quot;%o&quot;;    // octal</span></a>
<a class="sourceLine" id="cb1-718" title="718"><span class="co">&quot;%%&quot;;    // prints %</span></a>
<a class="sourceLine" id="cb1-719" title="719"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-720" title="720"></a>
<a class="sourceLine" id="cb1-721" title="721"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-722" title="722"><span class="co">// Order of Evaluation</span></a>
<a class="sourceLine" id="cb1-723" title="723"><span class="co">///////////////////////////////////////</span></a>
<a class="sourceLine" id="cb1-724" title="724"></a>
<a class="sourceLine" id="cb1-725" title="725"><span class="co">// From top to bottom, top has higher precedence</span></a>
<a class="sourceLine" id="cb1-726" title="726"><span class="co">//---------------------------------------------------//</span></a>
<a class="sourceLine" id="cb1-727" title="727"><span class="co">//        Operators                  | Associativity //</span></a>
<a class="sourceLine" id="cb1-728" title="728"><span class="co">//---------------------------------------------------//</span></a>
<a class="sourceLine" id="cb1-729" title="729"><span class="co">// () [] -&gt; .                        | left to right //</span></a>
<a class="sourceLine" id="cb1-730" title="730"><span class="co">// ! ~ ++ -- + = *(type) sizeof      | right to left //</span></a>
<a class="sourceLine" id="cb1-731" title="731"><span class="co">// * / %                             | left to right //</span></a>
<a class="sourceLine" id="cb1-732" title="732"><span class="co">// + -                               | left to right //</span></a>
<a class="sourceLine" id="cb1-733" title="733"><span class="co">// &lt;&lt; &gt;&gt;                             | left to right //</span></a>
<a class="sourceLine" id="cb1-734" title="734"><span class="co">// &lt; &lt;= &gt; &gt;=                         | left to right //</span></a>
<a class="sourceLine" id="cb1-735" title="735"><span class="co">// == !=                             | left to right //</span></a>
<a class="sourceLine" id="cb1-736" title="736"><span class="co">// &amp;                                 | left to right //</span></a>
<a class="sourceLine" id="cb1-737" title="737"><span class="co">// ^                                 | left to right //</span></a>
<a class="sourceLine" id="cb1-738" title="738"><span class="co">// |                                 | left to right //</span></a>
<a class="sourceLine" id="cb1-739" title="739"><span class="co">// &amp;&amp;                                | left to right //</span></a>
<a class="sourceLine" id="cb1-740" title="740"><span class="co">// ||                                | left to right //</span></a>
<a class="sourceLine" id="cb1-741" title="741"><span class="co">// ?:                                | right to left //</span></a>
<a class="sourceLine" id="cb1-742" title="742"><span class="co">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | right to left //</span></a>
<a class="sourceLine" id="cb1-743" title="743"><span class="co">// ,                                 | left to right //</span></a>
<a class="sourceLine" id="cb1-744" title="744"><span class="co">//---------------------------------------------------//</span></a>
<a class="sourceLine" id="cb1-745" title="745"></a>
<a class="sourceLine" id="cb1-746" title="746"><span class="co">/******************************* Header Files **********************************</span></a>
<a class="sourceLine" id="cb1-747" title="747"></a>
<a class="sourceLine" id="cb1-748" title="748"><span class="co">Header files are an important part of C as they allow for the connection of C</span></a>
<a class="sourceLine" id="cb1-749" title="749"><span class="co">source files and can simplify code and definitions by separating them into</span></a>
<a class="sourceLine" id="cb1-750" title="750"><span class="co">separate files.</span></a>
<a class="sourceLine" id="cb1-751" title="751"></a>
<a class="sourceLine" id="cb1-752" title="752"><span class="co">Header files are syntactically similar to C source files but reside in &quot;.h&quot;</span></a>
<a class="sourceLine" id="cb1-753" title="753"><span class="co">files. They can be included in your C source file by using the precompiler</span></a>
<a class="sourceLine" id="cb1-754" title="754"><span class="co">command #include &quot;example.h&quot;, given that example.h exists in the same directory</span></a>
<a class="sourceLine" id="cb1-755" title="755"><span class="co">as the C file.</span></a>
<a class="sourceLine" id="cb1-756" title="756"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-757" title="757"></a>
<a class="sourceLine" id="cb1-758" title="758"><span class="co">/* A safe guard to prevent the header from being defined too many times. This */</span></a>
<a class="sourceLine" id="cb1-759" title="759"><span class="co">/* happens in the case of circle dependency, the contents of the header is    */</span></a>
<a class="sourceLine" id="cb1-760" title="760"><span class="co">/* already defined.                                                           */</span></a>
<a class="sourceLine" id="cb1-761" title="761"><span class="pp">#ifndef EXAMPLE_H </span><span class="co">/* if EXAMPLE_H is not yet defined. */</span></a>
<a class="sourceLine" id="cb1-762" title="762"><span class="pp">#define EXAMPLE_H </span><span class="co">/* Define the macro EXAMPLE_H. */</span></a>
<a class="sourceLine" id="cb1-763" title="763"></a>
<a class="sourceLine" id="cb1-764" title="764"><span class="co">/* Other headers can be included in headers and therefore transitively */</span></a>
<a class="sourceLine" id="cb1-765" title="765"><span class="co">/* included into files that include this header.                       */</span></a>
<a class="sourceLine" id="cb1-766" title="766"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb1-767" title="767"></a>
<a class="sourceLine" id="cb1-768" title="768"><span class="co">/* Like for c source files, macros can be defined in headers */</span></a>
<a class="sourceLine" id="cb1-769" title="769"><span class="co">/* and used in files that include this header file.          */</span></a>
<a class="sourceLine" id="cb1-770" title="770"><span class="pp">#define EXAMPLE_NAME &quot;Dennis Ritchie&quot;</span></a>
<a class="sourceLine" id="cb1-771" title="771"></a>
<a class="sourceLine" id="cb1-772" title="772"><span class="co">/* Function macros can also be defined.  */</span></a>
<a class="sourceLine" id="cb1-773" title="773"><span class="pp">#define ADD(a, b) ((a) + (b))</span></a>
<a class="sourceLine" id="cb1-774" title="774"></a>
<a class="sourceLine" id="cb1-775" title="775"><span class="co">/* Notice the parenthesis surrounding the arguments -- this is important to   */</span></a>
<a class="sourceLine" id="cb1-776" title="776"><span class="co">/* ensure that a and b don&#39;t get expanded in an unexpected way (e.g. consider */</span></a>
<a class="sourceLine" id="cb1-777" title="777"><span class="co">/* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an  */</span></a>
<a class="sourceLine" id="cb1-778" title="778"><span class="co">/* incorrect result)                                                          */</span></a>
<a class="sourceLine" id="cb1-779" title="779"></a>
<a class="sourceLine" id="cb1-780" title="780"><span class="co">/* Structs and typedefs can be used for consistency between files. */</span></a>
<a class="sourceLine" id="cb1-781" title="781"><span class="kw">typedef</span> <span class="kw">struct</span> Node</a>
<a class="sourceLine" id="cb1-782" title="782">{</a>
<a class="sourceLine" id="cb1-783" title="783">    <span class="dt">int</span> val;</a>
<a class="sourceLine" id="cb1-784" title="784">    <span class="kw">struct</span> Node *next;</a>
<a class="sourceLine" id="cb1-785" title="785">} Node;</a>
<a class="sourceLine" id="cb1-786" title="786"></a>
<a class="sourceLine" id="cb1-787" title="787"><span class="co">/* So can enumerations. */</span></a>
<a class="sourceLine" id="cb1-788" title="788"><span class="kw">enum</span> traffic_light_state {GREEN, YELLOW, RED};</a>
<a class="sourceLine" id="cb1-789" title="789"></a>
<a class="sourceLine" id="cb1-790" title="790"><span class="co">/* Function prototypes can also be defined here for use in multiple files,  */</span></a>
<a class="sourceLine" id="cb1-791" title="791"><span class="co">/* but it is bad practice to define the function in the header. Definitions */</span></a>
<a class="sourceLine" id="cb1-792" title="792"><span class="co">/* should instead be put in a C file.                                       */</span></a>
<a class="sourceLine" id="cb1-793" title="793">Node createLinkedList(<span class="dt">int</span> *vals, <span class="dt">int</span> len);</a>
<a class="sourceLine" id="cb1-794" title="794"></a>
<a class="sourceLine" id="cb1-795" title="795"><span class="co">/* Beyond the above elements, other definitions should be left to a C source */</span></a>
<a class="sourceLine" id="cb1-796" title="796"><span class="co">/* file. Excessive includes or definitions should, also not be contained in */</span></a>
<a class="sourceLine" id="cb1-797" title="797"><span class="co">/* a header file but instead put into separate headers or a C file.          */</span></a>
<a class="sourceLine" id="cb1-798" title="798"></a>
<a class="sourceLine" id="cb1-799" title="799"><span class="pp">#endif </span><span class="co">/* End of the if precompiler directive. */</span></a></code></pre></div>
<h2 id="further-reading">Further Reading</h2>
<p>Best to find yourself a copy of <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka âThe C Programming Languageâ</a> It is <em>the</em> book about C, written by Dennis Ritchie, the creator of C, and Brian Kernighan. Be careful, though - itâs ancient and it contains some inaccuracies (well, ideas that are not considered good anymore) or now-changed practices.</p>
<p>Another good resource is <a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a> (not free).</p>
<p>If you have a question, read the <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>
<p>Itâs very important to use proper spacing, indentation and to be consistent with your coding style in general. Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the <a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>
<p>Other than that, Google is your friend.</p>
<p>[1] <a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isnât sizeof for a struct equal to the sum of sizeof of each member?</a></p>
</body>
</html>
