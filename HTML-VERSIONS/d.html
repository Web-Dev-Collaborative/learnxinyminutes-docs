<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>d.html</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<div class="sourceCode" id="cb1"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// You know what&#39;s coming...</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">module</span> hello;</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> std.stdio;</a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">// args is optional</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="dt">void</span> main(<span class="bu">string</span>[] args) {</a>
<a class="sourceLine" id="cb1-8" title="8">    writeln(<span class="st">&quot;Hello, World!&quot;</span>);</a>
<a class="sourceLine" id="cb1-9" title="9">}</a></code></pre></div>
<p>If you’re like me and spend way too much time on the internet, odds are you’ve heard about <a href="http://dlang.org/">D</a>. The D programming language is a modern, general-purpose, multi-paradigm language with support for everything from low-level features to expressive high-level abstractions.</p>
<p>D is actively developed by a large group of super-smart people and is spearheaded by <a href="https://en.wikipedia.org/wiki/Walter_Bright">Walter Bright</a> and <a href="https://en.wikipedia.org/wiki/Andrei_Alexandrescu">Andrei Alexandrescu</a>. With all that out of the way, let’s look at some examples!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> std.stdio;</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">void</span> main() {</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="co">// Conditionals and loops work as expected.</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10000</span>; i++) {</a>
<a class="sourceLine" id="cb2-7" title="7">        writeln(i);</a>
<a class="sourceLine" id="cb2-8" title="8">    }</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="co">// &#39;auto&#39; can be used for inferring types.</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="kw">auto</span> n = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="co">// Numeric literals can use &#39;_&#39; as a digit separator for clarity.</span></a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="kw">while</span>(n &lt; <span class="dv">10_000</span>) {</a>
<a class="sourceLine" id="cb2-15" title="15">        n += n;</a>
<a class="sourceLine" id="cb2-16" title="16">    }</a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18">    <span class="kw">do</span> {</a>
<a class="sourceLine" id="cb2-19" title="19">        n -= (n / <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb2-20" title="20">    } <span class="kw">while</span>(n &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-21" title="21"></a>
<a class="sourceLine" id="cb2-22" title="22">    <span class="co">// For and while are nice, but in D-land we prefer &#39;foreach&#39; loops.</span></a>
<a class="sourceLine" id="cb2-23" title="23">    <span class="co">// The &#39;..&#39; creates a continuous range, including the first value</span></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="co">// but excluding the last.</span></a>
<a class="sourceLine" id="cb2-25" title="25">    <span class="kw">foreach</span>(n; <span class="dv">1</span>..<span class="dv">1_000_000</span>) {</a>
<a class="sourceLine" id="cb2-26" title="26">        <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb2-27" title="27">            writeln(n);</a>
<a class="sourceLine" id="cb2-28" title="28">    }</a>
<a class="sourceLine" id="cb2-29" title="29"></a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="co">// There&#39;s also &#39;foreach_reverse&#39; when you want to loop backwards.</span></a>
<a class="sourceLine" id="cb2-31" title="31">    <span class="kw">foreach_reverse</span>(n; <span class="dv">1</span>..<span class="dt">int</span>.<span class="dt">max</span>) {</a>
<a class="sourceLine" id="cb2-32" title="32">        <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb2-33" title="33">            writeln(n);</a>
<a class="sourceLine" id="cb2-34" title="34">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-35" title="35">            writeln(<span class="st">&quot;No!&quot;</span>);</a>
<a class="sourceLine" id="cb2-36" title="36">        }</a>
<a class="sourceLine" id="cb2-37" title="37">    }</a>
<a class="sourceLine" id="cb2-38" title="38">}</a></code></pre></div>
<p>We can define new types with <code>struct</code>, <code>class</code>, <code>union</code>, and <code>enum</code>. Structs and unions are passed to functions by value (i.e. copied) and classes are passed by reference. Furthermore, we can use templates to parameterize all of these on both types and values!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// Here, &#39;T&#39; is a type parameter. Think &#39;&lt;T&gt;&#39; from C++/C#/Java.</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">struct</span> LinkedList(T) {</a>
<a class="sourceLine" id="cb3-3" title="3">    T data = <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="co">// Use &#39;!&#39; to instantiate a parameterized type. Again, think &#39;&lt;T&gt;&#39;.</span></a>
<a class="sourceLine" id="cb3-6" title="6">    LinkedList!(T)* next;</a>
<a class="sourceLine" id="cb3-7" title="7">}</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="kw">class</span> BinTree(T) {</a>
<a class="sourceLine" id="cb3-10" title="10">    T data = <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="co">// If there is only one template parameter, we can omit the parentheses.</span></a>
<a class="sourceLine" id="cb3-13" title="13">    BinTree!T left;</a>
<a class="sourceLine" id="cb3-14" title="14">    BinTree!T right;</a>
<a class="sourceLine" id="cb3-15" title="15">}</a>
<a class="sourceLine" id="cb3-16" title="16"></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="kw">enum</span> Day {</a>
<a class="sourceLine" id="cb3-18" title="18">    Sunday,</a>
<a class="sourceLine" id="cb3-19" title="19">    Monday,</a>
<a class="sourceLine" id="cb3-20" title="20">    Tuesday,</a>
<a class="sourceLine" id="cb3-21" title="21">    Wednesday,</a>
<a class="sourceLine" id="cb3-22" title="22">    Thursday,</a>
<a class="sourceLine" id="cb3-23" title="23">    Friday,</a>
<a class="sourceLine" id="cb3-24" title="24">    Saturday,</a>
<a class="sourceLine" id="cb3-25" title="25">}</a>
<a class="sourceLine" id="cb3-26" title="26"></a>
<a class="sourceLine" id="cb3-27" title="27"><span class="co">// Use alias to create abbreviations for types.</span></a>
<a class="sourceLine" id="cb3-28" title="28"><span class="kw">alias</span> IntList = LinkedList!<span class="dt">int</span>;</a>
<a class="sourceLine" id="cb3-29" title="29"><span class="kw">alias</span> NumTree = BinTree!<span class="dt">double</span>;</a>
<a class="sourceLine" id="cb3-30" title="30"></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="co">// We can create function templates as well!</span></a>
<a class="sourceLine" id="cb3-32" title="32">T max(T)(T a, T b) {</a>
<a class="sourceLine" id="cb3-33" title="33">    <span class="kw">if</span>(a &lt; b)</a>
<a class="sourceLine" id="cb3-34" title="34">        <span class="kw">return</span> b;</a>
<a class="sourceLine" id="cb3-35" title="35"></a>
<a class="sourceLine" id="cb3-36" title="36">    <span class="kw">return</span> a;</a>
<a class="sourceLine" id="cb3-37" title="37">}</a>
<a class="sourceLine" id="cb3-38" title="38"></a>
<a class="sourceLine" id="cb3-39" title="39"><span class="co">// Use the ref keyword to ensure pass by reference. That is, even if &#39;a&#39; and &#39;b&#39;</span></a>
<a class="sourceLine" id="cb3-40" title="40"><span class="co">// are value types, they will always be passed by reference to &#39;swap()&#39;.</span></a>
<a class="sourceLine" id="cb3-41" title="41"><span class="dt">void</span> swap(T)(<span class="kw">ref</span> T a, <span class="kw">ref</span> T b) {</a>
<a class="sourceLine" id="cb3-42" title="42">    <span class="kw">auto</span> temp = a;</a>
<a class="sourceLine" id="cb3-43" title="43"></a>
<a class="sourceLine" id="cb3-44" title="44">    a = b;</a>
<a class="sourceLine" id="cb3-45" title="45">    b = temp;</a>
<a class="sourceLine" id="cb3-46" title="46">}</a>
<a class="sourceLine" id="cb3-47" title="47"></a>
<a class="sourceLine" id="cb3-48" title="48"><span class="co">// With templates, we can also parameterize on values, not just types.</span></a>
<a class="sourceLine" id="cb3-49" title="49"><span class="kw">class</span> Matrix(<span class="dt">uint</span> m, <span class="dt">uint</span> n, T = <span class="dt">int</span>) {</a>
<a class="sourceLine" id="cb3-50" title="50">    T[m] rows;</a>
<a class="sourceLine" id="cb3-51" title="51">    T[n] columns;</a>
<a class="sourceLine" id="cb3-52" title="52">}</a>
<a class="sourceLine" id="cb3-53" title="53"></a>
<a class="sourceLine" id="cb3-54" title="54"><span class="kw">auto</span> mat = <span class="kw">new</span> Matrix!(<span class="dv">3</span>, <span class="dv">3</span>); <span class="co">// We&#39;ve defaulted type &#39;T&#39; to &#39;int&#39;.</span></a></code></pre></div>
<p>Speaking of classes, let’s talk about properties for a second. A property is roughly a function that may act like an lvalue, so we can have the syntax of POD structures (<code>structure.x = 7</code>) with the semantics of getter and setter methods (<code>object.setX(7)</code>)!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// Consider a class parameterized on types &#39;T&#39; &amp; &#39;U&#39;.</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">class</span> MyClass(T, U) {</a>
<a class="sourceLine" id="cb4-3" title="3">    T _data;</a>
<a class="sourceLine" id="cb4-4" title="4">    U _other;</a>
<a class="sourceLine" id="cb4-5" title="5">}</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">// And &quot;getter&quot; and &quot;setter&quot; methods like so:</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">class</span> MyClass(T, U) {</a>
<a class="sourceLine" id="cb4-9" title="9">    T _data;</a>
<a class="sourceLine" id="cb4-10" title="10">    U _other;</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="co">// Constructors are always named &#39;this&#39;.</span></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">this</span>(T t, U u) {</a>
<a class="sourceLine" id="cb4-14" title="14">        <span class="co">// This will call the setter methods below.</span></a>
<a class="sourceLine" id="cb4-15" title="15">        data = t;</a>
<a class="sourceLine" id="cb4-16" title="16">        other = u;</a>
<a class="sourceLine" id="cb4-17" title="17">    }</a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="co">// getters</span></a>
<a class="sourceLine" id="cb4-20" title="20">    @property T data() {</a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="kw">return</span> _data;</a>
<a class="sourceLine" id="cb4-22" title="22">    }</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24">    @property U other() {</a>
<a class="sourceLine" id="cb4-25" title="25">        <span class="kw">return</span> _other;</a>
<a class="sourceLine" id="cb4-26" title="26">    }</a>
<a class="sourceLine" id="cb4-27" title="27"></a>
<a class="sourceLine" id="cb4-28" title="28">    <span class="co">// setters</span></a>
<a class="sourceLine" id="cb4-29" title="29">    @property <span class="dt">void</span> data(T t) {</a>
<a class="sourceLine" id="cb4-30" title="30">        _data = t;</a>
<a class="sourceLine" id="cb4-31" title="31">    }</a>
<a class="sourceLine" id="cb4-32" title="32"></a>
<a class="sourceLine" id="cb4-33" title="33">    @property <span class="dt">void</span> other(U u) {</a>
<a class="sourceLine" id="cb4-34" title="34">        _other = u;</a>
<a class="sourceLine" id="cb4-35" title="35">    }</a>
<a class="sourceLine" id="cb4-36" title="36">}</a>
<a class="sourceLine" id="cb4-37" title="37"></a>
<a class="sourceLine" id="cb4-38" title="38"><span class="co">// And we use them in this manner:</span></a>
<a class="sourceLine" id="cb4-39" title="39"><span class="dt">void</span> main() {</a>
<a class="sourceLine" id="cb4-40" title="40">    <span class="kw">auto</span> mc = <span class="kw">new</span> MyClass!(<span class="dt">int</span>, <span class="bu">string</span>)(<span class="dv">7</span>, <span class="st">&quot;seven&quot;</span>);</a>
<a class="sourceLine" id="cb4-41" title="41"></a>
<a class="sourceLine" id="cb4-42" title="42">    <span class="co">// Import the &#39;stdio&#39; module from the standard library for writing to</span></a>
<a class="sourceLine" id="cb4-43" title="43">    <span class="co">// console (imports can be local to a scope).</span></a>
<a class="sourceLine" id="cb4-44" title="44">    <span class="kw">import</span> std.stdio;</a>
<a class="sourceLine" id="cb4-45" title="45"></a>
<a class="sourceLine" id="cb4-46" title="46">    <span class="co">// Call the getters to fetch the values.</span></a>
<a class="sourceLine" id="cb4-47" title="47">    writefln(<span class="st">&quot;Earlier: data = %d, str = %s&quot;</span>, mc.data, mc.other);</a>
<a class="sourceLine" id="cb4-48" title="48"></a>
<a class="sourceLine" id="cb4-49" title="49">    <span class="co">// Call the setters to assign new values.</span></a>
<a class="sourceLine" id="cb4-50" title="50">    mc.data = <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb4-51" title="51">    mc.other = <span class="st">&quot;eight&quot;</span>;</a>
<a class="sourceLine" id="cb4-52" title="52"></a>
<a class="sourceLine" id="cb4-53" title="53">    <span class="co">// Call the getters again to fetch the new values.</span></a>
<a class="sourceLine" id="cb4-54" title="54">    writefln(<span class="st">&quot;Later: data = %d, str = %s&quot;</span>, mc.data, mc.other);</a>
<a class="sourceLine" id="cb4-55" title="55">}</a></code></pre></div>
<p>With properties, we can add any amount of logic to our getter and setter methods, and keep the clean syntax of accessing members directly!</p>
<p>Other object-oriented goodies at our disposal include interfaces, abstract classes, and overriding methods. D does inheritance just like Java: Extend one class, implement as many interfaces as you please.</p>
<p>We’ve seen D’s OOP facilities, but let’s switch gears. D offers functional programming with first-class functions, <code>pure</code> functions, and immutable data. In addition, all of your favorite functional algorithms (map, filter, reduce and friends) can be found in the wonderful <code>std.algorithm</code> module!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> std.algorithm : map, filter, reduce;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">import</span> std.range : iota; <span class="co">// builds an end-exclusive range</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> std.stdio;</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="dt">void</span> main() {</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="co">// We want to print the sum of a list of squares of even ints</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co">// from 1 to 100. Easy!</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="co">// Just pass lambda expressions as template parameters!</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="co">// You can pass any function you like, but lambdas are convenient here.</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="kw">auto</span> num = iota(<span class="dv">1</span>, <span class="dv">101</span>).filter!(x =&gt; x % <span class="dv">2</span> == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-12" title="12">                           .map!(y =&gt; y ^^ <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-13" title="13">                           .reduce!((a, b) =&gt; a + b);</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    writeln(num);</a>
<a class="sourceLine" id="cb5-16" title="16">}</a></code></pre></div>
<p>Notice how we got to build a nice Haskellian pipeline to compute num? That’s thanks to a D innovation know as Uniform Function Call Syntax (UFCS). With UFCS, we can choose whether to write a function call as a method or free function call! Walter wrote a nice article on this <a href="http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394">here.</a> In short, you can call functions whose first parameter is of some type A on any expression of type A as a method.</p>
<p>I like parallelism. Anyone else like parallelism? Sure you do. Let’s do some!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode d"><code class="sourceCode d"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// Let&#39;s say we want to populate a large array with the square root of all</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co">// consecutive integers starting from 1 (up until the size of the array), and we</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">// want to do this concurrently taking advantage of as many cores as we have</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">// available.</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">import</span> std.stdio;</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">import</span> std.parallelism : parallel;</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">import</span> std.math : sqrt;</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="dt">void</span> main() {</a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="co">// Create your large array</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="kw">auto</span> arr = <span class="kw">new</span> <span class="dt">double</span>[<span class="dv">1_000_000</span>];</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="co">// Use an index, access every array element by reference (because we&#39;re</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="co">// going to change each element) and just call parallel on the array!</span></a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="kw">foreach</span>(i, <span class="kw">ref</span> elem; parallel(arr)) {</a>
<a class="sourceLine" id="cb6-17" title="17">        elem = sqrt(i + <span class="fl">1.0</span>);</a>
<a class="sourceLine" id="cb6-18" title="18">    }</a>
<a class="sourceLine" id="cb6-19" title="19">}</a></code></pre></div>
</body>
</html>
